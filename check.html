
<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="description" content="Pengurutan adalah masalah klasik tentang mengubah urutan elemen-elemen (yang bisa dibandingkan, seperti bilangan bulat, bilangan pecahan, strings, dsb) dari sebuah larik (senarai) ke urutan tertentu (menaik, tidak-menurun (menaik atau datar), menurun, tidak-menaik (menurun atau datar), terurut secara abjad, dsb).Ada banyak algoritma-algoritma pengurutan, dan masing-masing memiliki kekuatan-kekuatan maupun kekurangan-kekurangan.Pengurutan biasanya digunakan sebagai masalah pembuka dalam berbagai kelas-kelas Ilmu Komputer untuk menjelaskan berbagai ide-ide algoritma.Tanpa kehilangan makna umum, kami menggunakan asumsi bahwa kita akan mengurutkan hanya bilangan-bilangan bulat, tidak harus unik, ke dalam urutan tidak-menurun di visualisasi ini. Cobalah klik Bubble Sort untuk animasi contoh pengurutan daftar 5 bilangan-bilangan bulat yang tidak beratur (dengan duplikat) diatas.">
<meta name="keywords" content="Pengurutan Bubble Selection Seleksi Insertion Insersi Merge Randomized Quick Counting Radix">
 
<meta name="csrf-token" content="MEOOXmYvzYv6CeBn1Y6tWoV3KTNyFF458dJojBxk">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="https://visualgo.net/img/png/sorting.png">
<title>Pengurutan (Bubble, Seleksi (Selection), Insersi (Insertion), Merge, Quick, Counting, Radix) - VisuAlgo</title>
<link rel="icon" href="https://visualgo.net/img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="https://visualgo.net/img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="https://visualgo.net/img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="https://visualgo.net/img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="https://visualgo.net/img/favicon.png">
<link rel="stylesheet" href="https://visualgo.net/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="https://visualgo.net/fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="https://visualgo.net/css/common-1.0.0.css">
<link rel="stylesheet" href="https://visualgo.net/css/viz-1.0.3.css">
<link rel="stylesheet" href="https://visualgo.net/css/visual.css">
<link rel="stylesheet" href="https://visualgo.net/css/drawgraph-1.0.1.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }
    </style>
<style>
#create-userdefined-input input { width: 300px; }

text {
  fill: black;
  font: 20px sans-serif;
  text-anchor: middle;
}

#viz-radix-sort-canvas {
  position: fixed;
  top: 50%;
  left: 50%;
  margin-top: -250px;
  margin-left: -500px;
  height: 500px;
  width: 1000px;
}

div .radix-sort-element {
  position: absolute;
  border: 1px solid black;
  width: 55px;
  font: 20px sans-serif;
  color: black;
}

#radix-sort-bucket-labels-collection {
  position: absolute;
  bottom: 0px;
  left: 0px;
}

.radix-sort-bucket-label {
  position: absolute;
  border-top: 1px solid black;
  width: 57px;
  font: 20px sans-serif;
  color: black;
}

#sort-viz {
  width: 100%;
  text-align: center;
  overflow: hidden;
  padding-top: 10px;
}
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#gdpr-popup, #reload-mobile-popup, #message-popup {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#gdpr-popup p, #reload-mobile-popup p, #message-popup p {
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#gdpr-popup .gdpr-button, #reload-mobile-popup .inner-button, #message-popup .inner-button {
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="id" selected>id</option>
</select>
<span style="color: white; font-family: monospace">/sorting</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id='title-Bubble' class='selected-viz'>Bubble</a>
<a id='title-Selection'>Select</a>
<a id='title-Insertion'>Insert</a>
<a id='title-Merge'>Merge</a>
<a id='title-Quick'>Quick</a>
<a id='title-RandomizedQuick'>R-Quick</a>
<a id='title-Counting'>Count</a>
<a id='title-Radix'>Radix</a>
</span>
</span>

<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id='mode-button' style="background-color: rgb(0,0,0)!important;" title='exploration'>Mode Eksplorasi &#9663;</div>
<div id='other-modes' style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title='e-Lecture' style="background-color: rgb(0,0,0)!important;">Mode Kuliah Maya</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "MEOOXmYvzYv6CeBn1Y6tWoV3KTNyFF458dJojBxk",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick=mobilePlaybackRewind()><img src="https://visualgo.net/img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick=mobilePlaybackPauseOrPlay()><img src="https://visualgo.net/img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick=mobilePlaybackPauseOrPlay()><img src="https://visualgo.net/img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick=mobilePlaybackForward()><img src="https://visualgo.net/img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'><div id='speed-input'></div><div id='viz-speed-value'>1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="https://visualgo.net/img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="https://visualgo.net/img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="https://visualgo.net/img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="https://visualgo.net/img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="https://visualgo.net/img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="https://visualgo.net/img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='e-lecture' class='panel'></div> 
<div id='e-lecture-timeline'></div>
<div id='e-lecture-f1map'>
<div class="e-lecture-f1map-sector" sectorNo=1></div>
<div class="e-lecture-f1map-sector" sectorNo=2></div>
<div class="e-lecture-f1map-sector" sectorNo=3></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Masalah dan Algoritma Pengurutan</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Motivasi - Ide-Ide Menarik Info Komputer</option>
<option value="1-2">&nbsp;&nbsp;&nbsp;1-2. Motivasi - Aplikasi-Aplikasi</option>
<option value="1-3">&nbsp;&nbsp;&nbsp;1-3. Beberapa Petunjuk-Petunjuk</option>
<option value="2">2. Aksi-Aksi</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Masukkan Input Anda Sendiri</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. Jalankan Algoritma Pengurutan Terpilih</option>
<option value="3">3. Visualisasi</option>
<option value="4">4. Algoritma-Algoritma Pengurutan Umum</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Singkatan-Singkatan</option>
<option value="5">5. 3 O(N^2) Algoritma Berbasis-Pembandingan</option>
<option value="6">6. (Dasar) Analisa Algoritma-Algoritma</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Prasyarat Matematik</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Apa Itu?</option>
<option value="6-3">&nbsp;&nbsp;&nbsp;6-3. Mengukur Waktu Runtime Sesungguhnya?</option>
<option value="6-4">&nbsp;&nbsp;&nbsp;6-4. Menghitung # Operasi (1)</option>
<option value="6-5">&nbsp;&nbsp;&nbsp;6-5. Menghitung # Operasi (2)<br></option>
<option value="6-6">&nbsp;&nbsp;&nbsp;6-6. Analisa <i>Asymptotic</i></option>
<option value="6-7">&nbsp;&nbsp;&nbsp;6-7. Mengabaikan Koefisien dari Term Paling Depan</option>
<option value="6-8">&nbsp;&nbsp;&nbsp;6-8. Batas Atas: Notasi Big-O</option>
<option value="6-9">&nbsp;&nbsp;&nbsp;6-9. Notasi Big-O (Matematik)</option>
<option value="6-10">&nbsp;&nbsp;&nbsp;6-10. Term-Term Pertumbuhan</option>
<option value="6-11">&nbsp;&nbsp;&nbsp;6-11. Term-Term Pertumbuhan (Divisualisasikan/Dibandingkan)<br></option>
<option value="7">7. Bubble Sort</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Bubble Sort: Kode C++ dan Analisa</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Bubble Sort: Diberhentikan Lebih Awal</option>
 <option value="7-3">&nbsp;&nbsp;&nbsp;7-3. Jawaban</option>
<option value="8">8. Selection Sort</option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. Selection Sort, Kode C++ &amp; Analisa</option>
<option value="8-2">&nbsp;&nbsp;&nbsp;8-2. Kuis</option>
<option value="9">9. Insertion Sort</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. Insertion Sort, Kode C++ dan Analisa 1</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Insertion Sort: Analisa 2</option>
<option value="9-3">&nbsp;&nbsp;&nbsp;9-3. Kuis Mini</option>
<option value="10">10. 2.5 O(N log N) Pengurutan Pembandingan</option>
<option value="11">11. Merge Sort</option>
<option value="11-1">&nbsp;&nbsp;&nbsp;11-1. Sub-rutin Penting, O(N) Merge</option>
<option value="11-2">&nbsp;&nbsp;&nbsp;11-2. Implementasi C++ dari Sub-rutin Merge</option>
<option value="11-3">&nbsp;&nbsp;&nbsp;11-3. Paradigma Divide and Conquer</option>
<option value="11-4">&nbsp;&nbsp;&nbsp;11-4. Merge Sort Sebagai Algoritma D&amp;C</option>
<option value="11-5">&nbsp;&nbsp;&nbsp;11-5. Implementasi C++ dari Merge Sort</option>
<option value="11-6">&nbsp;&nbsp;&nbsp;11-6. Demonstrasi</option>
<option value="11-7">&nbsp;&nbsp;&nbsp;11-7. Merge Sort: Analisa Bagian 1</option>
<option value="11-8">&nbsp;&nbsp;&nbsp;11-8. Merge Sort: Analisa Bagian 2</option>
<option value="11-9">&nbsp;&nbsp;&nbsp;11-9. Merge Sort: Analisa Bagian 3</option>
<option value="11-10">&nbsp;&nbsp;&nbsp;11-10. Bagus dan Jeleknya</option>
<option value="11-11">&nbsp;&nbsp;&nbsp;11-11. Jawabannya</option>
<option value="12">12. Quick Sort</option>
<option value="12-1">&nbsp;&nbsp;&nbsp;12-1. Quick Sort sebagai Algoritma D&amp;C</option>
<option value="12-2">&nbsp;&nbsp;&nbsp;12-2. Sub-rutin Penting, O(N) Partition</option>
<option value="12-3">&nbsp;&nbsp;&nbsp;12-3. Jawabannya</option>
<option value="12-4">&nbsp;&nbsp;&nbsp;12-4. Partition - Lanjutan</option>
<option value="12-5">&nbsp;&nbsp;&nbsp;12-5. Partisi - Kasus ketika a[k] &gt; p</option>
<option value="12-6">&nbsp;&nbsp;&nbsp;12-6. Partition - Kasus ketika a[k] &lt; p</option>
<option value="12-7">&nbsp;&nbsp;&nbsp;12-7. Implementasi C++ dari Partition</option>
<option value="12-8">&nbsp;&nbsp;&nbsp;12-8. Implementasi C++ dari Quick Sort</option>
<option value="12-9">&nbsp;&nbsp;&nbsp;12-9. Demonstrasi</option>
<option value="12-10">&nbsp;&nbsp;&nbsp;12-10. Quick Sort: Analisa Bagian 1</option>
<option value="12-11">&nbsp;&nbsp;&nbsp;12-11. Quick Sort: Analisa Bagian 2</option>
<option value="12-12">&nbsp;&nbsp;&nbsp;12-12. Quick Sort: Analisa Bagian 3</option>
<option value="12-13">&nbsp;&nbsp;&nbsp;12-13. Quick Sort: Kasus Terbaik (Jarang)</option>
<option value="13">13. Quick Sort Acak</option>
<option value="13-1">&nbsp;&nbsp;&nbsp;13-1. Analisa "Magis"</option>
<option value="13-2">&nbsp;&nbsp;&nbsp;13-2. Jawabannya</option>
<option value="14">14. 2 O(N) Algoritma Tidak Membandingkan</option>
<option value="14-1">&nbsp;&nbsp;&nbsp;14-1. Batas Bawah dari Algoritma Pengurutan</option>
<option value="15">15. Counting Sort</option>
<option value="16">16. Radix Sort</option>
<option value="16-1">&nbsp;&nbsp;&nbsp;16-1. Algoritma Pengurutan Terbaik?</option>
<option value="16-2">&nbsp;&nbsp;&nbsp;16-2. Jawabannya</option>
<option value="17">17. Properti Tambahan dari Algoritma Pengurutan</option>
<option value="17-1">&nbsp;&nbsp;&nbsp;17-1. Pengurutan Di-Tempat</option>
<option value="17-2">&nbsp;&nbsp;&nbsp;17-2. Pengurutan Stabil</option>
<option value="17-3">&nbsp;&nbsp;&nbsp;17-3. Performa Cache</option>
<option value="18">18. Kuis-Kuis</option>
<option value="18-1">&nbsp;&nbsp;&nbsp;18-1. Kuis #1</option>
<option value="18-2">&nbsp;&nbsp;&nbsp;18-2. Kuis #2</option>
<option value="19">19. Tambahan-Tambahan</option>
<option value="19-1">&nbsp;&nbsp;&nbsp;19-1. Tantangan</option>
<option value="19-2">&nbsp;&nbsp;&nbsp;19-2. Indeks/Perhitungan Inversi</option>
<option value="19-3">&nbsp;&nbsp;&nbsp;19-3. Implementasi</option>
<option value="19-4">&nbsp;&nbsp;&nbsp;19-4. Kuis Online</option>
<option value="19-5">&nbsp;&nbsp;&nbsp;19-5. Latihan-Latihan Online Judge</option>
</select>
</div>
<div class='electure-print' title='Print the e-Lecture note' style='z-index=8001;'>&#9997;</div>
<div class='electure-end' title='Close the e-Lecture mode' style='z-index=8001;'>&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Pengurutan adalah masalah klasik tentang mengubah urutan elemen-elemen (yang bisa dibandingkan, seperti bilangan bulat, bilangan pecahan, <i>strings</i>, dsb) dari sebuah larik (senarai) ke urutan tertentu (menaik, tidak-menurun (menaik atau datar), menurun, tidak-menaik (menurun atau datar), terurut secara abjad, dsb).</p><br><p>Ada banyak algoritma-algoritma pengurutan, dan masing-masing memiliki kekuatan-kekuatan maupun kekurangan-kekurangan.<br></p><p><br></p><div><p>Pengurutan biasanya digunakan sebagai masalah pembuka dalam berbagai kelas-kelas Ilmu Komputer untuk menjelaskan berbagai ide-ide algoritma.</p><br><p>Tanpa kehilangan makna umum, kami menggunakan asumsi bahwa kita akan mengurutkan hanya <b>bilangan-bilangan bulat</b>, tidak harus unik, ke dalam <b>urutan tidak-menurun</b> di visualisasi ini. Cobalah klik <span class="slide-actions" onclick="doButtonAction11()">Bubble Sort</span> untuk animasi contoh pengurutan daftar 5 bilangan-bilangan bulat yang tidak beratur (dengan duplikat) diatas.</p></div>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class='electure-next' data-nextid="1-1" title='Go to the next slide 1-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sorting problem has a variety of interesting algorithmic solutions that embody many Computer Science ideas:</p><ol><li><a href=""><u>Comparison</u></a> versus <a href=""><u>non-comparison</u></a> based strategies,</li><li>Iterative versus Recursive implementation,</li><li>Divide-and-Conquer paradigm (e.g., <a href=""><u>Merge Sort</u></a> or <a href=""><u>Quick Sort</u></a>),</li><li>Best/Worst/Average-case Time Complexity analysis,</li><li><a href=""><u>Randomized Algorithms</u></a>, etc.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class='electure-prev' data-nextid="1" title='Go to the previous slide 1'>&larr;</div>
<div class='electure-next' data-nextid="1-2" title='Go to the next slide 1-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-1-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Ketika sebuah larik (bilangan bulat) <b>A</b> terurut, banyak masalah-masalah yang berhubungan dengan <b>A</b> menjadi mudah (atau lebih mudah):</p><ol><li>Mencari nilai spesifik <b>v</b> di dalam larik <b>A</b>,</li><li>Mencari nilai terkecil/terbesar atau nilai terkecil/terbesar ke-k di larik (statis) <b>A</b>,</li><li>Mengetes keunikan dan menghapus duplikat dari larik <b>A</b>,</li><li>Menghitung seberapa banyak nilai spesifik <b>v</b> muncul dalam larik <b>A</b>,</li><li>Himpunan Irisan/Gabungan dari larik <b>A</b> dan larik terurut lainnya yaitu <b>B</b>,</li><li>Mencari pasangan target <b>x</b> ∈ <b>A</b> dan <b>y</b> ∈ <b>A</b> sehingga <b>x+y</b> sama dengan nilai target <b>z</b>,</li><li>Menghitung banyak nilai di larik <b>A</b>&nbsp;yang berada pada jangkauan [<b>lo</b>..<b>hi</b>], dsb.</li></ol><p>Diskusi: Dalam kelas-kelas nyata, instruktor bisa membahas aplikasi-aplikasi ini dengan lebih detail.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class='electure-prev' data-nextid="1-1" title='Go to the previous slide 1-1'>&larr;</div>
<div class='electure-next' data-nextid="1-3" title='Go to the next slide 1-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-1-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class='electure-prev' data-nextid="1-2" title='Go to the previous slide 1-2'>&larr;</div>
<div class='electure-next' data-nextid="2" title='Go to the next slide 2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="bottom:140px;left:60px;width:500px;">
<p>Ada dua aksi yang anda dapat lakukan di visualisasi ini.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="1-3" title='Go to the previous slide 1-3'>&larr;</div>
<div class='electure-next' data-nextid="2-1" title='Go to the next slide 2-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-2-1" class="electure-dialog" style="bottom:140px;left:60px;width:500px;">
<p>Aksi pertama adalah tentang mendefinisikan masukan <b>anda sendiri</b>, sebuah larik/daftar <b>A</b> yang:</p><ol><li>Betul-betul acak,</li><li>Acak tapi terurut (dalam urutan tidak-menurun atau tidak-menaik),</li><li>Acak tetapi <b>hampir</b> terurut (dalam urutan tidak-menurun atau tidak-menaik),</li><li>Acak dan memiliki banyak duplikat-duplikat (sehingga jangkauan bilangan-bilangan bulatnya kecil), atau</li><li>Didefinisikan oleh anda sendiri.</li></ol><p>Dalam mode Eksplorasi, anda dapat bereksperimen dengan berbagai algoritma-algoritma pengurutan yang tersedia di visualisasi ini untuk mengetahui masukan-masukan terbaik dan terjelek untuk algoritma-algoritma tersebut.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="2" title='Go to the previous slide 2'>&larr;</div>
<div class='electure-next' data-nextid="2-2" title='Go to the next slide 2-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-2-2" class="electure-dialog" style="bottom:140px;left:60px;width:500px;">
<p>Aksi kedua adalah yang terpenting: Jalankan algoritma pengurutan yang sedang aktif dengan meng-klik tombol "Urutkan".</p><br><p>Ingat bahwa anda dapat mengubah algoritma yang aktif dengan meng-klik <a href=""><u>singkatan</u></a> di sisi atas dari halaman visualisasi ini.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="2-1" title='Go to the previous slide 2-1'>&larr;</div>
<div class='electure-next' data-nextid="3" title='Go to the next slide 3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Lihat visualisasi/animasi dari algoritma pengurutan terpilih disini.</p><p><br></p><p>Tanpa kehilangan makna umum, kami hanya menunjukkan bilangan-bilangan bulat didalam visualisasi ini dan tujuan kami adalah untuk mengurutkan mereka dari status awal ke status terurut tidak-menurun. Ingat, tidak-menurun berarti pada umumnya urutan menaik (atau membesar), tetapi karena bisa ada duplikat-duplikat, bisa ada garis datar/sama diantara dua bilangan-bilangan bulat bersisian yang bernilai sama.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="2-2" title='Go to the previous slide 2-2'>&larr;</div>
<div class='electure-next' data-nextid="4" title='Go to the next slide 4'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:60px;left:220px;width:500px;">
<p>Di bagian atas halaman ini, anda akan melihat daftar berbagai algoritma-algoritma pengurutan yang biasanya diajarkan dalam kelas-kelas Ilmu Komputer. Untuk mengaktifkan algoritma tertentu, pilihlah <a href=""><u>singkatan</u></a> dari nama algoritma yang bersangkutan sebelum meng-klik "Urutkan".</p><div><br><p>Untuk memfasilitasi keberagaman, kami akan mengacak algoritma yang aktif setiap kali halaman ini ditampilkan.</p><br><p>Enam algoritma pertama adalah <b>berbasis-pembandingan</b> sedangkan dua terakhir tidak. Kita akan membahas ide ini <a href=""><u>di pertengahan</u></a> Kuliah Maya ini.</p><br><p>Tiga algoritma ditengah adalah algoritma pengurutan yang bersifat <b>rekursif </b>sedangkan sisanya biasa diimplementasikan secara iteratif.</p></div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="3" title='Go to the previous slide 3'>&larr;</div>
<div class='electure-next' data-nextid="4-1" title='Go to the next slide 4-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:60px;left:220px;width:500px;">
<p>Supaya muat di layar, kami menyingkat nama-nama algoritma menjadi tiga karakter saja:</p><ol><li>Algoritma-Algorithma Pengurutan berbasis-pembandingan:<ol><li>BUB - <i>Bubble Sort</i>,</li><li>SEL - <i>Selection Sort</i>,</li><li>INS - <i>Insertion Sort</i>,</li><li>MER - <i>Merge Sort</i> (implementasi rekursif),</li><li>QUI - <i>Quick Sort</i> (implementasi rekursif),</li><li>R-Q - <i>Quick Sort</i> Acak (implementasi rekursif).</li></ol></li><li>Algoritma-Algoritma Pengurutan tidak berbasis-pembandingan:<ol><li>COU - <i>Counting Sort</i>,</li><li>RAD - <i>Radix Sort</i>.</li></ol></li></ol>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="4" title='Go to the previous slide 4'>&larr;</div>
<div class='electure-next' data-nextid="5" title='Go to the next slide 5'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita akan membahas tiga algoritma-algoritma pengurutan berbasis-pembandingan di beberapa slides berikutnya:</p><ol><li><a href=""><u><i>Bubble Sort</i></u></a>,</li><li><a href=""><u><i>Selection Sort</i></u></a>,</li><li><a href=""><u><i>Insertion Sort</i></u></a>.</li></ol><p>Mereka disebut <b>berbasis-pembandingan</b> karena mereka membandingkan pasangan elemen-elemen dari sebuah larik dan menentukan apakah akan menukar posisi mereka atau tidak.</p><br><p>Ketiga algoritma-algoritma pengurutan ini adalah yang termudah untuk diimplementasikan tetapi juga bukan yang paling efisien, karena mereka berjalan dalam kompleksitas waktu O(<b>N</b><sup>2</sup>).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="4-1" title='Go to the previous slide 4-1'>&larr;</div>
<div class='electure-next' data-nextid="6" title='Go to the next slide 6'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sebelum kita memulai diskusi berbagai algoritma-algoritma pengurutan, adalah ide bagus untuk membahas dasar-dasar dari analisa algoritma secara asimptotik, sehingga anda dapat mengikuti diskusi-diskusi dari berbagai algoritma-algoritma pengurutan O(<b>N</b>^2), O(<b>N</b> log <b>N</b>), dan spesial O(<b>N</b>) nantinya.</p><br><p><i>Section</i> ini bisa dilompati jika anda sudah mengetahui topik ini.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="5" title='Go to the previous slide 5'>&larr;</div>
<div class='electure-next' data-nextid="6-1" title='Go to the next slide 6-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Anda butuh untuk sudah mengerti/mengingat hal-hal ini:<br>-. Logaritma dan Eksponen, misalkan log<sub>2</sub>(1024) = 10, 2<sup>10</sup> = 1024<br>-. Deret Aritmetika, misalkan 1+2+3+4+…+10 = 10*11/2 = 55<br>-. Deret Geometri, misalkan 1+2+4+8+..+1024 = 1*(1-2<sup>11</sup>)/(1-2) = 2047<br>-. Fungsi Linear/Kuadratik/Kubik, misalkan f1(x) = x+2, f2(x) = x<sup>2</sup>+x-1, f3(x) = x<sup>3</sup>+2x<sup>2</sup>-x+7<br>-. Fungsi Langit-Langit, Lantai, dan Absolut, misalkan ceil(3.1) = 4, floor(3.1) = 3, abs(-7) = 7</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6" title='Go to the previous slide 6'>&larr;</div>
<div class='electure-next' data-nextid="6-2" title='Go to the next slide 6-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Analisis algoritma adalah sebuah proses untuk mengevaluasi secara keras sumber daya (waktu dan ruang) yang dibutuhkan oleh sebuah algoritma dan merepresentasikan hasil dari evaluasi tersebut dengan sebuah formula (sederhana).</p><br><p>Kebutuhan waktu/ruang dari sebuah algoritma juga disebut sebagai kompleksitas waktu/ruang dari algoritma tersebut, masing-masing.</p><br><p>Untuk modul ini, kita lebih memfokuskan kepada persyaratan waktu dari berbagai algoritma-algoritma pengurutan.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-1" title='Go to the previous slide 6-1'>&larr;</div>
<div class='electure-next' data-nextid="6-3" title='Go to the next slide 6-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita bisa mengukur waktu perjalanan aktual dari sebuah program dengan menggunakan waktu jam dinding atau dengan memasukkan kode pengukuran-waktu kedalam program kita, misalkan lihat kode yang ditunjukkan didalam <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.cpp" target="_blank"><u>SpeedTest.cpp</u></a> | <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.py" target="_blank"><u>py</u></a> | <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.java" target="_blank"><u>java</u></a>.</p><br><p>Tetapi, waktu perjalanan aktual tidak berarti banyak ketika membandingan dua algoritma-algoritma karena mereka mungkin ditulis dalam bahasa-bahasa yang berbeda, menggunakan set-set data yang berbeda, atau berjalan pada komputer-komputer yang berbeda.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-2" title='Go to the previous slide 6-2'>&larr;</div>
<div class='electure-next' data-nextid="6-4" title='Go to the next slide 6-4'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Daripada mengukur waktu sebenarnya, kita bisa menghitung # dari operasi-operasi (aritmetik, penugasan, pembandingan, dsb). Ini adalah cara untuk mengukur efesiensi karena waktu eksekusi dari sebuah algoritma terkorelasi dengan # operasi-operasi yang dibutuhkannya.</p><br><p>Lihat kode yang ditunjukkan di <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.cpp" target="_blank"><u>SpeedTest.cpp</u></a> | <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.py" target="_blank"><u>py</u></a> | <a href="https://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/SpeedTest.java" target="_blank"><u>java</u></a> dan komentar-komentarnya (terutama tentang bagaimana mendapatkan nilai final dari variabel <i>counter</i>).</p><br><p>Mengetahu jumlah operasi-operasi (persis) yang dibutuhkan oleh sebuah algoritma, kita bisa menyatakan sesuatu seperti ini: Algoritma <b>X</b> membutuhkan <b>2n<sup>2</sup> + 100n</b> operasi-operasi untuk menyelesaikan masalah dengan ukuran <b>n</b>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-3" title='Go to the previous slide 6-3'>&larr;</div>
<div class='electure-next' data-nextid="6-5" title='Go to the next slide 6-5'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Jika waktu <b>t</b> yang dibutuhkan untuk sebuah operasi diketahu, maka kita bisa menyatakan bahwa algoritma <b>X</b> membutuhkan <b>(2n<sup>2</sup> + 100n)t</b> unit-unit waktu untuk menyelesaikan masalah dengan ukuran <b>n</b>.</p><br><p>Tetapi, waktu <b>t</b> tergantung dari faktor-faktor yang disebut sebelumnya, misalkan bahasa-bahasa, kompiler-kompiler, dan komputer-komputer yang berbeda, dsb.</p><br><p>Oleh karena itu, daripada menghubungkan analisa ke waktu <b>t</b> yang sebenarnya, kita bisa menyatakan bahwa algoritma <b>X</b> membutuhkan waktu yang <b>proporsional terhadap 2n<sup>2</sup> + 100n</b> untuk menyelesaikan masalah dengan ukuran <b>n</b>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-4" title='Go to the previous slide 6-4'>&larr;</div>
<div class='electure-next' data-nextid="6-6" title='Go to the next slide 6-6'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Analisa Asimtotik adalah sebuah analisa algoritma-algoritma yang berfokus pada penganalisaan masalah-masalah dengan <b>ukuran masukan n yang besar</b>, memikirkan hanya <b>term tertinggi saja </b>dari formula, dan <b>mengabaikan koefisien </b>dari term tertinggi.</p><br><p>Kita memilih term tertinggi karena term-term yang lebih kecil berkontribusi lebih sedikit kepada biaya total saat ukuran masukan bertumbuh besar, misalkan untuk f(n) = 2n<sup>2</sup> + 100n, kita punya:<br>f(1000) = 2*1000<sup>2</sup> + 100*1000 = 2.1M, versus<br>f(100000) = 2*100000<sup>2</sup> + 100*100000 = 20010M.<br>(sadari bahwa term yang lebih kecil 100n memiliki kontribusi yang lebih kecil).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-5" title='Go to the previous slide 6-5'>&larr;</div>
<div class='electure-next' data-nextid="6-7" title='Go to the next slide 6-7'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Misalkan dua algoritma-algoritma memiliki 2n<sup>2</sup> dan 30n<sup>2</sup> sebagai term-term tertinggi.</p><br><p>Meskipun waktu sebenarnya akan berbeda karena konstanta-konstanta yang berbeda, laju-laju pertumbuhan dari waktu eksekusi adalah sama.</p><br><p>Dibandingkan dengan algoritma lain dengan term tertinggi n<sup>3</sup>, perbedaan dari laju pertumbuhan adalah faktor yang jauh lebih dominan.</p><br><p>Maka, kita bisa melepaskan koefisien dari term tertinggi ketika mempelajari kompleksitas algoritma.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-6" title='Go to the previous slide 6-6'>&larr;</div>
<div class='electure-next' data-nextid="6-8" title='Go to the next slide 6-8'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Jika algoritma A membutuhkan waktu proporsional terhadap <b>f(n)</b>, kita bilang bahwa algoritma A berada dalam order f(n).</p><br><p>Kita menulis bahwa algoritma A mempunyai kompleksitas waktu <b>O(f(n))</b>, dimana <b>f(n)</b> adalah fungsi laju pertumbuhan untuk algoritma A.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-7" title='Go to the previous slide 6-7'>&larr;</div>
<div class='electure-next' data-nextid="6-9" title='Go to the next slide 6-9'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Secara matematis, sebuah algoritma adalah O(<b>f(n)</b>) jika ada sebuah konstanta <b>k</b> dan sebuah bilangan bulat positif <b>n0</b> sehingga algoritma A membutuhkan tidak lebih dari <b>k*f(n)</b> unit-unit waktu untuk menyelesaikan sebuah masalah dengan ukuran <b>n ≥ n0</b>, yaitu, jika ukuran masalah lebih besari dari <b>n0</b>, algoritma A (selalu) dibatasi dari atas oleh formula sederhana <b>k*f(n)</b> ini.</p><br><center><img src="https://visualgo.net/img/big_O_notation.png" width="300" alt="Big-O Notation"></center><br><p>Catat bahwa: <b>n0</b> dan <b>k</b> tidak unik dan bisa ada beberapa banyak <b>f(n)</b> valid yang memungkinkan.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-8" title='Go to the previous slide 6-8'>&larr;</div>
<div class='electure-next' data-nextid="6-10" title='Go to the next slide 6-10'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Dalam analisa asimtotik, sebuah formula bisa disederhanakan menjadi sebuah term tunggal dengan koefisien 1.</p><br><p>Term tersebut disebut sebagai term pertumbuhan (tingkat pertumbuhan, urutan pertumbuhan, urutan besar).</p><br><p>Term-term pertumbuhan yang paling umum dapat diurutkan dari yang paling cepat ke paling lambat sebagai berikut:<br>O(<b>1</b>)/waktu konstan &lt; O(log <b>n</b>)/waktu logaritmik &lt; O(<b>n</b>)/waktu linear &lt;<br>O(<b>n</b> log <b>n</b>)/waktu kuasilinear &lt; O(<b>n</b><sup>2</sup>)/waktu kuadratik &lt; O(<b>n</b><sup>3</sup>)/waktu kubik &lt;<br>O(2<sup><b>n</b></sup>)/waktu eksponensial &lt; O(<b>n</b>!)/waktu juga-eksponensial &lt; ∞ (misalkan, perulangan tak berakhir).</p><br><p>Catat bahwa ada beberapa kompleksitas-kompleksitas waktu yang umum lainnya yang tidak ditunjukkan (lihat juga visualisasi di slide berikutnya)).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-9" title='Go to the previous slide 6-9'>&larr;</div>
<div class='electure-next' data-nextid="6-11" title='Go to the next slide 6-11'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-6-11" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<img src="https://visualgo.net/img/growth_rates.png" width="500" alt="Common Growth Terms"><br><p>Kita akan melihat tiga laju-laju pertumbuhan yang berbeda O(<b>n<sup>2</sup></b>), O(<b>n log n</b>), dan O(<b>n</b>) sepanjang sisa dari modul pengurutan ini.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-10" title='Go to the previous slide 6-10'>&larr;</div>
<div class='electure-next' data-nextid="7" title='Go to the next slide 7'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
Diberikan sebuah larik berisi <b>N</b> elemen-elemen, <i>Bubble Sort</i> akan:<div><ol><li><b>Membandingkan</b> pasangan yang bersebelahan (a, b),</li><li>Menukar pasangan tersebut bila tidak pada urutan yang seharusnya (dalam kasus ini, ketika a &gt; b),</li><li>Ulangi Langkah 1 dan 2 hingga kita sampai di akhir larik<br>(pasangan terakhir adalah elemen ke (<b>N</b>-2) dan (<b>N</b>-1) karena kita menggunakan indeks basis-0),</li><li>Pada saat ini, elemen terbesar akan terletak pada posisi terakhir.<br>Kita lalu mengurangi <b>N</b> dengan 1 dan kembali ke Langkah 1 sampai kita mendapat <b>N = 1</b>.</li></ol></div><p><span style="text-align: center;">Tanpa basa-basi lagi, mari coba <span class="slide-actions" onclick="doButtonAction11()">Bubble Sort</span> pada larik contoh kecil [29, 10, 14, 37, 14].</span></p><p><br></p><p>Anda akan melihat animasi &#39;seperti-gelembung&#39; jika anda membayangkan elemen-elemen yang besar &#39;menggelembung keatas&#39; (atau sebenarnya &#39;bergerak ke sisi kanan dari larik&#39;).<br></p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="6-11" title='Go to the previous slide 6-11'>&larr;</div>
<div class='electure-next' data-nextid="7-1" title='Go to the next slide 7-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void bubbleSort(int a[], int N) { // versi standar<br>  for (; N &gt; 0; --N) // N iterasi-iterasi<br>    for (int i = 0; i &lt; N-1; ++i) // kecuali terakhir, O(N)<br>      if (a[i] &gt; a[i+1]) // tidak dalam urutan tidak-menurun<br>        swap(a[i], a[i+1]); // tukar dalam O(1)<br>}<br></pre><p>Pembandingan dan penukaran membutuhkan waktu yang dibatasi oleh sebuah konstanta, mari sebut saja dengan <b>c</b>. Lalu, ada dua perulangan (<i>loop</i>) yang bertingkat (<i>nested</i>) dalam <i>Bubble Sort</i> standar. Perulangan<i> </i>(<i>loop</i>) luar berjalan tepat sebanyak <b>N</b> iterasi. Tetapi pengulangan (loop) dalam menjadi sedikit lebih pendek pada setiap iterasi:</p><ol><li>Saat i=0, (<b>N</b>−1) iterasi (dari pembandingan-pembandingan dan kemungkinan pertukaran-pertukaran),</li><li>Saat i=1, (<b>N</b>−2) iterasi,<br>...,</li><li>Saat i=(<b>N</b>−2), 1 iterasi,</li><li>Saat i=(<b>N</b>−1), 0 iterasi.</li></ol><p>Sehingga, jumlah total dari iterasi = (<b>N</b>−1)+(<b>N</b>−2)+...+1+0 = <b>N</b>*(<b>N</b>−1)/2 (<a href="https://en.wikipedia.org/wiki/Arithmetic_progression#Sum" target="_blank"><u>penurunan</u></a>)<br>Waktu total adalah = c*<b>N</b>*(<b>N</b>−1)/2 = O(<b>N</b>^2)</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="7" title='Go to the previous slide 7'>&larr;</div>
<div class='electure-next' data-nextid="7-2" title='Go to the next slide 7-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><i>Bubble Sort</i> sebenarnya tidak efisien dengan kompleksitas waktu <b>O(N^2)</b>. Bayangkan jika kita memiliki <b>N</b> = 10<sup>5</sup> angka-angka. Meskipun komputer kita sangat cepat dan dapat menghitung 10<sup>8</sup> operasi-operasi dalam 1 detik, <i>Bubble Sort</i> akan membutuhkan sekitar 100 detik untuk menyelesaikan tugas ini.</p><p><br></p><p>Tetapi, <i>Bubble Sort</i> dapat dihentikan lebih awal, misalkan pada contoh kecil yang telah terurut menaik diatas <span style="white-space: normal;">[3, 6, 11, 25, 39],&nbsp;</span><span class="slide-actions" onclick="doButtonAction11()">Bubble Sort</span> dapat dihentikan dalam waktu O(<b>N</b>).</p><br><p>Idenya mudah: Jika kita melalui perulangan dalam (<i>inner loop</i>) <b>tanpa melakukan pertukaran</b> sama sekali, itu berarti bahwa larik tersebut <b>sudah terurut</b> dan kita dapat menghentikan <i>Bubble Sort</i> pada saat itu.</p><br><p>Diskusi: Meskipun ide tersebut membuat <i>Bubble Sort</i> berjalan lebih cepat dalam kasus-kasus umum, ide ini tidak mengubah kompleksitas waktu <b>O(N^2)</b> dari <i>Bubble Sort</i>... Kenapa?</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="7-1" title='Go to the previous slide 7-1'>&larr;</div>
<div class='electure-next' data-nextid="7-3" title='Go to the next slide 7-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-7-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="7-2" title='Go to the previous slide 7-2'>&larr;</div>
<div class='electure-next' data-nextid="8" title='Go to the next slide 8'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Diberikan sebuah larik berisi <b>N</b> elemen dan <b>L</b> = 0, <i>Selection Sort</i> akan:<br></p><ol><li>Menemukan posisi <b>X</b> dari elemen terkecil dalam interval [<b>L...N</b>-1],</li><li>Tukar item ke-<b>X</b> dengan item ke-<b>L</b>,</li><li>Naikkan batas bawah <b>L</b> sebesar 1 dan kembail ke Langkah 1 sampai <b>L</b> = <b>N</b>-2.<br></li></ol><p>Mari coba <span class="slide-actions" onclick="doButtonAction8()">Selection Sort</span> pada larik contoh kecil yang sama <span style="white-space: normal;">[29, 10, 14, 37, 13]</span>.</p><br><p>Tanpa kehilangan makna umum, kita juga dapat mengimplementasikan <i>Selection Sort</i> secara terbalik:<br>Temukan posisi dari elemen terbesar <b>Y</b> dan tukar dengan elemen terakhir.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="7-3" title='Go to the previous slide 7-3'>&larr;</div>
<div class='electure-next' data-nextid="8-1" title='Go to the next slide 8-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-8-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void selectionSort(int a[], int N) {<br>  for (int L = 0; L &lt;= N-2; ++L) { // O(<b>N</b>)<br>    int X = min_element(a+L, a+N) - a; // O(<b>N</b>)<br>    swap(a[X], a[L]); // O(1), X may be equal to L (no actual swap)<br>  }<br>}</pre><p>Total: O(<b>N</b><sup>2</sup>) — To be precise, it is similar to <a href=""><u>Bubble Sort analysis</u></a>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="8" title='Go to the previous slide 8'>&larr;</div>
<div class='electure-next' data-nextid="8-2" title='Go to the next slide 8-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-8-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<input class="mcq-answer" id="mcq-answer-4" value="26" hidden><p>Quiz: <b>How many (real) swaps are required to sort [29, 10, 14, 37, 13] by Selection Sort?</b></p><form><input type="radio" name="mcq-4-choice" value="24"> 1<br><input type="radio" name="mcq-4-choice" value="25"> 2<br><input type="radio" name="mcq-4-choice" value="26"> 3<br><input type="radio" name="mcq-4-choice" value="27"> 4<br></form><button class="mcq-submit" id="submit-4">Submit</button> <span id="answer-status-4"></span>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="8-1" title='Go to the previous slide 8-1'>&larr;</div>
<div class='electure-next' data-nextid="9" title='Go to the next slide 9'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><i>Insertion Sort</i> mirip dengan bagaimana kebanyakan orang menyusun kartu <i>poker</i> di tangan. <img src="https://puu.sh/vfi6a/e532309371.png" alt="Tangan poker"></p><ol><li>Mulai dengan satu kartu di tangan,<br></li><li>Pilih kartu berikutnya dan masukkan ke dalam posisi yang benar,</li><li>Ulang langkah tersebut untuk seluruh kartu.</li></ol><p>Tanpa basa-basi lagi, mari coba <span class="slide-actions" onclick="doButtonAction10()">Insertion Sort</span> pada larik contoh kecil <span style="white-space: normal;">[40, 13, 20, 8]</span>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="8-2" title='Go to the previous slide 8-2'>&larr;</div>
<div class='electure-next' data-nextid="9-1" title='Go to the next slide 9-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void insertionSort(int a[], int N) {<br>  for (int i = 1; i &lt; N; ++i) { // O(N)<br>    int X = a[i]; // X adalah elemen untuk dimasukkan<br>    int j = i-1;<br>    for (; j &gt;= 0 &amp;&amp; a[j] &gt; X; --j) // bisa cepat atau lambat<br>      a[j+1] = a[j]; // buat tempat untuk X<br>    a[j+1] = X; // indeks j+1 adalah titik pemasukkan<br>  }<br>}</pre>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="9" title='Go to the previous slide 9'>&larr;</div>
<div class='electure-next' data-nextid="9-2" title='Go to the next slide 9-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Perulangan luar (<i>outer loop</i>) dijalankan <b>N</b>−1 kali, sepertinya ini cukup jelas.</p><p>Tetapi berapa kali perulangan dalam (<i>inner loop</i>) dilakukan tergantung pada masukan:<br></p><ol><li>Dalam kasus terbaik, larik sudah terurut menaik dan (a[j] &gt; X) selalu salah<br>Sehingga tidak ada pergeseran data yang terjadi dan perulangan dalam (<u><i>inner loop</i></u>) berjalan dalam O(<b>1</b>),</li><li>Dalam kasus terjelek, larik terurut terbalik (menurun) dan (a[j] &gt; X) selalu benar<br>Pemasukkan (<u><i>insertion</i></u>) selalu terjadi di depan larik dan perulangan dalam (<i>inner loop</i>) berjalan dalam O(<b>N</b>).</li></ol><p>Sehingga, waktu terbaik adalah O(<b>N × 1</b>) = O(<b>N</b>) dan waktu terburuk adalah O(<b>N × N</b>) = O(<b>N</b><sup>2</sup>).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="9-1" title='Go to the previous slide 9-1'>&larr;</div>
<div class='electure-next' data-nextid="9-3" title='Go to the next slide 9-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-9-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<input class="mcq-answer" id="mcq-answer-5" value="31" hidden><p>Quiz: <b>What is the complexity of Insertion Sort on any input array?</b></p><form><input type="radio" name="mcq-5-choice" value="28"> O(1)<br><input type="radio" name="mcq-5-choice" value="29"> O(N)<br><input type="radio" name="mcq-5-choice" value="30"> O(N log N)<br><input type="radio" name="mcq-5-choice" value="31"> O(N^2)<br></form><button class="mcq-submit" id="submit-5">Submit</button> <span id="answer-status-5"></span><br><br><p>Tanya instruktor anda bila anda tidak mengerti tentang hal ini atau baca catatan yang sejenis di <a href=""><u>slide ini</u></a>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="9-2" title='Go to the previous slide 9-2'>&larr;</div>
<div class='electure-next' data-nextid="10" title='Go to the next slide 10'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita akan membahas dua (dan setengah) algoritma-algoritma berbasis-pembandingan segera:</p><ol><li><a href=""><u><i>Merge Sort</i></u></a>,</li><li><a href=""><u><i>Quick Sort</i></u></a> dan <a href=""><u>versi acaknya</u></a> (yang hanya memiliki satu perubahan).</li></ol><p>Algoritma-algoritma pengurutan ini biasanya diimplementasikan secara rekursif, menggunakan paradigma pemecahan masalah <i>Divide and Conquer</i>, dan berjalan dalam waktu O(<b>N</b> log <b>N</b>) untuk <i>Merge Sort</i> dan O(<b>N</b> log <b>N</b>) <i>secara ekspektasi</i> untuk <i>Quick Sort</i> Acak.</p><br><p>PS: Versi tidak-acak dari <i>Quick Sort</i> sayangnya berjalan dalam waktu O(<b>N<sup>2</sup></b>).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="9-3" title='Go to the previous slide 9-3'>&larr;</div>
<div class='electure-next' data-nextid="11" title='Go to the next slide 11'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Diberikan sebuah larik berisi <b>N</b> elemen, <i>Merge Sort</i> akan:</p><ol><li>Menggabungkan tiap pasang elemen (yang secara <i>default</i> terurut) menjadi larik-larik berukuran 2 elemen,</li><li>Menggabungkan tiap pasang larik-larik tersebut menjadi larik-larik berukuran 4 elemen, Ulangi proses ini...,</li><li>Langkah terakhir: Menggabungkan 2 larik-larik yang sudah terurut dengan jumlah <b>N</b>/2 elemen (untuk memudahkan diskusi, kita berasumsi bahwa <b>N</b> genap) untuk mendapatkan larik yang terurut penuh dengan jumlah <b>N</b> elemen.<br></li></ol><p>Ini hanyalah ide general dan kita membutuhkan beberapa detail tambahan sebelum kita bisa membahas bentuk sebenarnya dari <i>Merge Sort</i>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="10" title='Go to the previous slide 10'>&larr;</div>
<div class='electure-next' data-nextid="11-1" title='Go to the next slide 11-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Kita akan membahas dengan detil algoritma <i>Merge Sort</i> ini dengan pertama-tama membahas sub-rutin terpentingnya: Proses penggabungan (<samp>merge</samp>) dalam O(<b>N</b>).</p><br><p>Diberikan dua larik yang sudah terurut, A dan B, dengan ukuran <b>N<sub>1</sub></b> dan <b>N<sub>2</sub></b>, kita dapat dengan efisien menggabungkan mereka mejadi satu larik terurut yang lebih besar dengan ukuran <b>N</b> = <b>N<sub>1</sub></b>+<b>N<sub>2</sub></b>, dalam waktu O(<b>N</b>).</p><br><p>Ini dapat diraih dengan cara membandingkan elemen terdepan dari kedua larik dan mengambil yang terkecil dari dua itu setiap waktu. Tetapi, sub-rutin <samp>merge</samp> yang sederhana tapi cepat O(<b>N</b>) ini akan membutuhkan larik tambahan untuk melakukan proses penggabungan ini dengan benar.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11" title='Go to the previous slide 11'>&larr;</div>
<div class='electure-next' data-nextid="11-2" title='Go to the next slide 11-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void merge(int a[], int low, int mid, int high) {<br>  // subarray1 = a[low..mid], subarray2 = a[mid+1..high], terurut<br>  int N = high-low+1;<br>  int b[N]; // diskusi: kenapa kita butuh larik sementara b?<br>  int left = low, right = mid+1, bIdx = 0;<br>  while (left &lt;= mid &amp;&amp; right &lt;= high) // proses penggabungan<br>    b[bIdx++] = (a[left] &lt;= a[right]) ? a[left++] : a[right++];<br>  while (left &lt;= mid) b[bIdx++] = a[left++]; // sisanya, jika ada<br>  while (right &lt;= high) b[bIdx++] = a[right++]; // sisanya, jika ada<br>  for (int k = 0; k &lt; N; ++k) a[low+k] = b[k]; // kopi kembali<br>}<br></pre><p>Cobalah <span class="slide-actions" onclick="doButtonAction12()">Merge Sort</span> pada larik contoh <span style="white-space: normal;">[1, 5, 19, 20, 2, 11, 15, 17]&nbsp;</span>yang sebagian pertamanya telah terurut [1, 5, 19, 20] dan sebagian keduanya juga telah terurut [2, 11, 15, 17]. Fokus kepada penggabungan terakhir dari algoritma <i>Merge Sort</i>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-1" title='Go to the previous slide 11-1'>&larr;</div>
<div class='electure-next' data-nextid="11-3" title='Go to the next slide 11-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Sebelum kita lanjutkan, mari berbicara tentang <i>Divide and Conquer </i>(disingkat sebagai D&amp;C), sebuah paradigma pemecahan masalah yang kuat.</p><br><p>Algoritma <i>Divide and Conquer</i> menyelesaikan (sejenis) masalah — seperti masalah pengurutan kita — dalam beberapa langkah-langkah berikut:</p><ol><li>Langkah <i>Divide</i>: Membagi masalah yang asli dan besar menjadi masalah-masalah yang lebih kecil dan secara rekursif menyelesaikan masalah-masalah yang lebih kecil tersebut,</li><li>Langkah <i>Conquer</i>: Gabungkan hasil-hasil dari masalah-masalah yang lebih kecil tersebut untuk menghasilkan hasil dari masalah yang asli dan besar.</li></ol>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-2" title='Go to the previous slide 11-2'>&larr;</div>
<div class='electure-next' data-nextid="11-4" title='Go to the next slide 11-4'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><i>Merge Sort</i> adalah algoritma pengurutan bersifat <i>Divide and Conquer</i>.</p><br><p>Langkah pembagian (<i>divide</i>) mudah saja: Bagi larik yang sekarang menjadi dua bagian (sama besar jika <b>N</b> genap atau satu sisi satu elemen sedikit lebih besar jika <b>N</b> ganjil) dan lalu secara rekursif mengurutkan kedua bagian tersebut.</p><br><p>Langkah penaklukkan (<i>conquer</i>) adalah langkah yang melakukan usaha terbesar: Gabungkan dua bagian (yang sudah terurut) untuk membentuk larik yang terurut, menggunakan sub-rutin penggabungan (<i>merge</i>) <a href=""><u>yang dibahas sebelumnya</u></a>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-3" title='Go to the previous slide 11-3'>&larr;</div>
<div class='electure-next' data-nextid="11-5" title='Go to the next slide 11-5'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void mergeSort(int a[], int low, int high) {<br>  // larik yang akan diurutkan adalah a[low..high]<br>  if (low &lt; high) { // kasus dasar: low &gt;= high (0 or 1 item)<br>    int mid = (low+high) / 2;	<br>    mergeSort(a, low  , mid ); // bagi jadi dua bagian<br>    mergeSort(a, mid+1, high); // lalu urutkan secara rekursif<br>    merge(a, low, mid, high); // kuasai: sub-rutin merge<br>  }<br>}</pre>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-4" title='Go to the previous slide 11-4'>&larr;</div>
<div class='electure-next' data-nextid="11-6" title='Go to the next slide 11-6'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Dibandingkan dengan apa yang biasanya ditampilkan di banyak buku-buku teks Ilmu Komputer yang dicetak (karena buku-buku sifatnya statis), eksekusi sebenarnya dari <i>Merge Sort</i> <b>tidak</b> membagi kedua sub-larik <b>level demi level</b>, tetapi <i>Merge Sort</i> akan secara rekursif mengurutkan sub-larik <b>kiri</b> terlebih dahulu sebelum mengurutkan sub-larik <b>kanan</b>.<br></p><br><p>Lebih detailnya, menjalankan <span class="slide-actions" onclick="doButtonAction12()">Merge Sort</span> pada larik contoh [7, 2, 6, 3, 8, 4, 5], <i>Merge Sort</i> akan merekursi ke [7, 2, 6, 3], lalu [7, 2], lalu [7] (sebuah elemen tunggal, yang sudah terurut secara <i>default</i>), kembali, rekursi ke [2] (terurut), kembali, lalu menggabungkan [7, 2] menjadi [2, 7], sebelum <i>Merge Sort</i> memproses [6, 3] dan selanjutnya.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-5" title='Go to the previous slide 11-5'>&larr;</div>
<div class='electure-next' data-nextid="11-7" title='Go to the next slide 11-7'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Dalam <i>Merge Sort</i>, usaha terbanyak dilakukan dalam langkah <i>conquer</i>/<i>merge </i>karena langkah <i>divide</i> sebenarnya tidak melakukan apa-apa (dianggap O(<b>1</b>)).</p><br><p>Ketika kita memanggil <samp>merge(a, low, mid, high)</samp>, kita memproses <b>k = (high-low+1)</b> elemen.<br>Akan ada paling banyak <b>k-1</b> pembandingan.<br>Ada <b>k</b> perpindahan dari larik asli <b>a</b> ke larik temporer <b>b</b> dan <b>k</b> perpindahan lainnya untuk menyalin balik.<br>Secara total, jumlah operasi dalam operasi sub-rutin <samp>merge</samp> adalah &lt; 3<b>k</b>-1 = O(<b>k</b>).</p><br><p>Pertanyaan penting berikutnya adalah berapa kali sub-rutin <samp>merge</samp> ini dipanggil?</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-6" title='Go to the previous slide 11-6'>&larr;</div>
<div class='electure-next' data-nextid="11-8" title='Go to the next slide 11-8'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<img src="https://visualgo.net/img/merge.png" width="500" alt="The Recursion Tree of Merge Sort">
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-7" title='Go to the previous slide 11-7'>&larr;</div>
<div class='electure-next' data-nextid="11-9" title='Go to the next slide 11-9'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Level 1: 2^0=1 panggilan kepada merge() dengan <b>N</b>/2^1 elemen masing-masing, O(2^0 x 2 x <b>N</b>/2^1) = O(<b>N</b>)<br>Level 2: 2^1=2 panggilan kepada merge() dengan <b>N</b>/2^2 elemen masing-masing, O(2^1 x 2 x <b>N</b>/2^2) = O(<b>N</b>)<br>Level 3: 2^2=4 panggilan kepada merge() dengan <b>N</b>/2^3 elemen masing-masing, O(2^2 x 2 x <b>N</b>/2^3) = O(<b>N</b>)<br>...<br>Level (log <b>N</b>): 2^(log <b>N</b>-1) (atau <b>N</b>/2) panggilan kepada merge() dengan <b>N</b>/2^log <b>N</b> (or 1) elemen masing-masing, O(<b>N</b>)</p><br><p>Ada log <b>N</b> level dan di setiap level, kita melakukan usaha sebesar O(<b>N</b>), sehingga kompleksitas waktu seluruhnya adalah O(<b>N</b> log <b>N</b>). <a href=""><u>Nanti</u></a>, kita akan melihat bahwa ini adalah algoritma pengurutan (berbasis-pembandingan) yang sudah optimal, atau dengan kata lain, kita tidak bisa membuat algoritma lebih baik dari <i>Merge Sort</i> ini.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-8" title='Go to the previous slide 11-8'>&larr;</div>
<div class='electure-next' data-nextid="11-10" title='Go to the next slide 11-10'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-10" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Bagian bagus dari <i>Merge Sort</i> yang paling penting adalah garansi performa O(<b>N</b> log <b>N</b>), tidak tergantung pada urutan asli dari masukan. Dengan kata lain, <b>tidak ada</b> kasus tes yang bisa membuat <i>Merge Sort</i> berjalan lebih lambat dari O(<b>N</b> log <b>N</b>) untuk <b>segala </b>larik dengan <b>N</b> elemen.</p><br><p><i>Merge Sort</i> sangat cocok untuk mengurutkan masukan yang sangat besar karena O(<b>N</b> log <b>N</b>) bertumbuh jauh lebih lambat dari algoritma-algoritma pengurutan yang membutuhkan waktu O(<b>N</b><sup>2</sup>) seperti yang <a href=""><u>dibahas sebelumnya</u></a>.</p><br><p>Tetapi ada juga beberapa bagian yang tidak bagus dari <i>Merge Sort</i>. Pertama, sebenarnya tidak mudah untuk mengimplementasikan <i>Merge Sort</i> dari awal (<a href=""><u>tetapi sebenarnya kita tidak perlu melakukannya</u></a>). Kedua, <i>Merge Sort</i> membutuhkan tempat tambahan sebesar O(<b>N</b>) dalam <a href=""><u>proses penggabungan</u></a>, sehingga tidak efisien secara memori dan <a href=""><u>tidak di-tempat</u></a>. <span style="white-space: normal;">Ngomong-ngomong, bila anda tertarik untuk melihat apa yang sudah dilakukan untuk mengatasi bagian yang tidak bagus dari <i>Merge Sort</i> (klasik) ini, anda bisa membaca </span><a href="https://en.wikipedia.org/wiki/Merge_sort#Variants" target="_blank"><u>ini</u></a></p><p><br></p><p><i>Merge Sort</i> juga adalah algoritma <a href=""><u>pengurutan yang stabil</u></a>. Diskusi: Kenapa?</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-9" title='Go to the previous slide 11-9'>&larr;</div>
<div class='electure-next' data-nextid="11-11" title='Go to the next slide 11-11'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-11-11" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-10" title='Go to the previous slide 11-10'>&larr;</div>
<div class='electure-next' data-nextid="12" title='Go to the next slide 12'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><i>Quick Sort</i> adalah algoritma pengurutan lain yang juga berbasis <i>Divide and Conquer</i> (satu lagi yang telah dibahas di Kuliah Maya ini adalah <a href=""><u><i>Merge Sort</i></u></a>).</p><br><p>Kita akan melihat bahwa versi deterministik, tidak acak dari <i>Quick Sort</i> bisa memiliki kompleksitas waktu yang jelek, yaitu O(<b>N</b><sup>2</sup>) pada masukan jahat (<i>adversary</i>) sebelum kita melanjutkan pembahasan dengan versi <a href=""><u>acak</u></a> yang lebih bisa dipakai nantinya.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="11-11" title='Go to the previous slide 11-11'>&larr;</div>
<div class='electure-next' data-nextid="12-1" title='Go to the next slide 12-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Langkah <i>Divide</i>: Pilih elemen <b>p</b> (dinamai sebagai <i>pivot</i>)<br>Lalu partisi (<i>partition</i>) elemen-elemen <b>a[i..j]</b> menjadi tiga bagian: <b>a[i..m-1]</b>, <b>a[m]</b>, dan <b>a[m+1..j]</b>.<br><b>a[i..m-1]</b> (kemungkinan kosong) berisi elemen-elemen yang lebih kecil dari <b>p</b>.<br><b>a[m]</b> adalah <i>pivot</i> <b>p</b>, indeks <b>m</b> adalah posisi <b>p</b> yang benar didalam larik terurut <b>a </b>nantinya.<br><b>a[m+1..j]</b> (kemungkinan kosong) berisi elemen-elemen yang lebih besar <i>atau sama dengan</i> <b>p</b>.<br>Lalu, urutkan kedua bagian ini secara rekursif.</p><br><p>Langkah <i>Conquer</i>: Jangan kaget... Kita tidak melakukan apa-apa :O!</p><br><p>Jika anda membandingkan ini dengan <a href=""><u><i>Merge Sort</i></u></a>, anda akan melihat bahwa langkah-langkah D&amp;C dari <i>Quick Sort</i> terbalik total dengan <i>Merge Sort</i>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12" title='Go to the previous slide 12'>&larr;</div>
<div class='electure-next' data-nextid="12-2" title='Go to the next slide 12-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Kita akan membahas dengan detil algoritma <i>Quick Sort</i> ini dengan pertama-tama membahas sub-rutin terpentingnya: O(<b>N</b>) partition.</p><br><p>Untuk mempartisi <b>a[i..j]</b>, kita pertama-tama memilih <b>a[i]</b> sebagai <i>pivot</i> <b>p</b>.<br></p><p>Elemen-elemen sisanya (yaitu <b>a[i+1..j]</b>) terbagi jadi 3 wilayah:</p><ol><li><b>S1</b> = <b>a[i+1..m]</b> dimana elemen-elemennya &lt; <b>p</b>,</li><li><b>S2</b> = <b>a[m+1..k-1]</b> dimana elemen-elemennya ≥ <b>p</b>, dan</li><li>Tidak diketahui = <b>a[k..j]</b>, dimana elemen-elemennya belum dimasukkan ke <b>S1</b> atau <b>S2</b>.</li></ol><p>Diskusi: Kenapa kita memilih <b>p</b> = <b>a[i]</b>? Apakah ada pilihan-pilihan yang lain?</p><p><br></p><p>Diskusi yang lebih susah: Apakah baik untuk selalu menaruh item(-item) yang == <b>p</b> selalu ke S2?</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-1" title='Go to the previous slide 12-1'>&larr;</div>
<div class='electure-next' data-nextid="12-3" title='Go to the next slide 12-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-2" title='Go to the previous slide 12-2'>&larr;</div>
<div class='electure-next' data-nextid="12-4" title='Go to the next slide 12-4'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Pada awalnya, region <b>S1</b> dan <b>S2</b> dua-duanya kosong, yaitu semua elemen kecuali <i>pivot</i> <b>p</b> yang terpilih berada dalam region yang tidak diketahui.</p><br><p>Lalu, untuk setiap elemen <b>a[k]</b> di region yang tidak diketahui, kita membandingkan <b>a[k]</b> dengan <b>p</b> dan memutuskan satu dari tiga kasus berikut:</p><ol><li>Jika <b>a[k]</b> &gt; <b>p</b>, taruh <b>a[k]</b> di <b>S2</b>,</li><li>Jika <b>a[k] &lt; p</b>, taruh <b>a[k]</b> di <b>S1</b>,</li><li>Jika <b>a[k] == p</b>, lempar sebuah koin dan taruh <b>a[k]</b> ke <b>S1</b>/<b>S2</b> jika jatuh kepala/ekor, masing-masing.</li></ol><p>Ketiga kasus-kasus ini akan dijelaskan lebih detil di dua slide berikutnya.</p><br><p>Pada akhirnya, kita menukar <b>a[i]</b> dan <b>a[m]</b> untuk menaruh pivot <b>p</b> tepat diantara <b>S1</b> dan <b>S2</b>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-3" title='Go to the previous slide 12-3'>&larr;</div>
<div class='electure-next' data-nextid="12-5" title='Go to the next slide 12-5'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<img src="https://visualgo.net/img/partition1.png" width="500" alt="Case when a[k] ≥ p, increment k, extend S2 by 1 item">
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-4" title='Go to the previous slide 12-4'>&larr;</div>
<div class='electure-next' data-nextid="12-6" title='Go to the next slide 12-6'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<img src="https://visualgo.net/img/partition2.png" width="500" alt="Case when a[k] < p, increment m, swap a[k] with a[m], increment k, extend S1 by 1 item">
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-5" title='Go to the previous slide 12-5'>&larr;</div>
<div class='electure-next' data-nextid="12-7" title='Go to the next slide 12-7'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>int partition(int a[], int i, int j) {<br>  int p = a[i]; // p sebagai pivot<br>  int m = i; // S1 dan S2 pada mulanya kosong<br>  for (int k = i+1; k &lt;= j; ++k) { // jelajah bagian baru<br>    if ((a[k] &lt; p) || ((a[k] == p) &amp;&amp; (rand()%2 == 0))){ // case 2+3<br>      ++m;<br>      swap(a[k], a[m]); // algoritma C++ STL std::swap<br>    } // kita tidak melakukan apa-apa pada kasus 1: a[k] &gt; p<br>  }<br>  swap(a[i], a[m]); // langkah terakhir, tukar pivot dengan a[m]<br>  return m; // kembalikan indeks pivot<br>}</pre>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-6" title='Go to the previous slide 12-6'>&larr;</div>
<div class='electure-next' data-nextid="12-8" title='Go to the next slide 12-8'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>void quickSort(int a[], int low, int high) {<br>  if (low &lt; high) {<br>    int m = partition(a, low, high); // O(N)<br>    // a[low..high] ~&gt; a[low..m–1], pivot, a[m+1..high]<br>    quickSort(a, low, m-1); // urutkan sub-larik kiri<br>    // a[m] = pivot telah terurut setelah partition<br>    quickSort(a, m+1, high); // lalu urutkan sub-larik kanan<br>  }<br>}</pre>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-7" title='Go to the previous slide 12-7'>&larr;</div>
<div class='electure-next' data-nextid="12-9" title='Go to the next slide 12-9'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Coba <span class="slide-actions" onclick="doButtonAction13()">Quick Sort</span> pada larik contoh [27, 38, 12, 39, 29, 16]. Kita akan bahas langkah pertama dari partition sebagai berikut:<br>Kita set <b>p = a[0] = 27</b>.<br>Kita set <b>a[1] = 38</b> sebagai bagian <b>S2</b> jadi <b>S1 = {}</b> dan <b>S2 = {38}</b>.<br>Kita tukar <b>a[1] = 38</b> dengan <b>a[2] = 12</b> jadi <b>S1 = {12}</b> dan <b>S2 = {38}</b>.<br>Kita set <b>a[3] = 39</b> dan juga <b>a[4] = 29</b> berikutnya sebagai bagian <b>S2</b> jadi <b>S1 = {12}</b> dan <b>S2 = {38,39,29}</b>.<br>Kita tukar <b>a[2] = 38</b> dengan <b>a[5] = 16</b> jadi <b>S1 = {12,16}</b> dan <b>S2 = {39,29,38}</b>.<br>Kita tukar <b>p = a[0] = 27</b> dengan <b>a[2] = 16</b> jadi <b>S1 = {16,12}</b>, <b>p = {27}</b>, dan <b>S2 = {39,29,38}</b>.</p><br><p>Setelah ini, <b>a[2] = 27</b> dijamin terurut sekarang dan <i>Quick Sort</i> akan mengurutkan secara rekursif sisi kiri <b>a[0..1]</b> duluan dan nanti mengurutkan secara rekursif sisi kanan <b>a[3..5]</b>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-8" title='Go to the previous slide 12-8'>&larr;</div>
<div class='electure-next' data-nextid="12-10" title='Go to the next slide 12-10'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-10" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Pertama-tama, kita analisa biaya satu pemanggilan <samp>partition</samp>.</p><br><p>Didalam <samp>partition(a, i, j)</samp>, hanya ada satu <i>for-loop</i> yang diulang (j-i) kali. Karena j bisa sebesar <b>N</b>-1 dan i bisa sekecil 0, maka kompleksitas waktu dari partition adalah O(<b>N</b>).</p><br><p>Mirip dengan <a href=""><u>analisa <i>Merge Sort</i></u></a>, kompleksitas waktu dari <i>Quick Sort</i> tergantung seberapa banyak <samp>partition(a, i, j)</samp> dipanggil.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-9" title='Go to the previous slide 12-9'>&larr;</div>
<div class='electure-next' data-nextid="12-11" title='Go to the next slide 12-11'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-11" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Ketika larik <b>a</b> sudah dalam urutan menaik, misalkan <b>a</b> = [5, 18, 23, 39, 44, 50}, <span class="slide-actions" onclick="doButtonAction13()">Quick Sort</span><i> </i>akan mengatur <b>p = a[0] = 5</b>, dan akan mengembalikan <b>m = 0</b>, oleh karena itu membuat region <b>S1</b> <b>kosong</b> dan region <b>S2</b>: Semuanya kecuali pivot (<b>N</b>-1 elemen).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-10" title='Go to the previous slide 12-10'>&larr;</div>
<div class='electure-next' data-nextid="12-12" title='Go to the next slide 12-12'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-12" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Pada skenario terjelek tersebut, inilah yang terjadi:</p><br><img src="https://visualgo.net/img/qsort_worstcase.png" width="250" alt="Worst Case analysis of Quick Sort"><br><p>Partisi pertama membutuhkan waktu O(<b>N</b>), membagi <b>a</b> menjadi 0, 1, <b>N</b>-1 elemen-elemen, lalu rekursi ke-kanan.<br>Yang kedua membutuhkan waktu O(<b>N</b>-1), membagi <b>a</b> menjadi 0, 1, <b>N</b>-2 elemen-elemen, lalu rekursi ke-kanan lagi.<br>...<br>Sampai yang terakhir, uartisi ke <b>N</b> membagi <b>a</b> menjadi 0, 1, 1 elemen, dan rekursi <i>Quick Sort</i> berhenti.<br></p><br><p>Ini adalah pola klasik <b>N+(N-1)+(N-2)+...+1</b>, yang disederhanakan sebagai O(<b>N</b><sup>2</sup><span style="white-space: normal;">), analisa yang mirip dengan yang&nbsp;</span><a href="https://visualgo.net/translation/id/sorting/none/all/1?slide=6-1" style="white-space: normal;"><u>di slide analisa Bubble Sort ini</u></a><span style="white-space: normal;">...</span></p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-11" title='Go to the previous slide 12-11'>&larr;</div>
<div class='electure-next' data-nextid="12-13" title='Go to the next slide 12-13'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-12-13" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Skenario terbaik dari <i>Quick Sort</i> terjadi ketika partition selalu membagi larik menjadi <b>dua bagian yang sama besar</b>, seperti <a href=""><u><i>Merge Sort</i></u></a>.</p><br><p>Ketika itu terjadi, kedalaman rekursi hanyalah O(log <b>N</b>).</p><br><p>Karena setiap level membutuhkan O(<b>N</b>) pembandingan, kompleksitas waktu adalah O(<b>N</b> log <b>N</b>).</p><br><p>Coba <span class="slide-actions" onclick="doButtonAction13()">Quick Sort</span> di contoh larik masukan yang telah dipersiapkan secara khusus <span style="white-space: normal;">[4, 1, 3, 2, 6, 5, 7]</span>.</p><p>Pada prakteknya, hal ini jarang terjadi, sehingga kita harus memikirkan cara yang lebih baik: <a href=""><u><i>Quick Sort</i> Acak</u></a>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-12" title='Go to the previous slide 12-12'>&larr;</div>
<div class='electure-next' data-nextid="13" title='Go to the next slide 13'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-13" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Sama seperti <b><i>Quick Sort</i></b> tetapi sebelum menjalankan algoritma partisi, algoritma ini <b>secara acak </b>memilih sebuah pivot diantara <b>a[i..j]</b> dibandingkan dengan selalu memilih <b>a[i]</b> (atau indeks tetap lainnya diantara <b>[i..j]</b>) secara deterministik.</p><p><br></p><p>Latihan kecil: Implementasikan ide diatas pada implementasi yang ditunjukkan di <a href="https://visualgo.net/translation/id/sorting/noshown/all/1?slide=11-7"><u>slide ini</u></a>!<br></p><br><p>Coba <span class="slide-actions" onclick="doButtonAction14()">Random Quick Sort</span> pada larik yang besar dan agak acak <b>a</b><span style="white-space: normal;">&nbsp;</span><span style="white-space: normal;">= [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48] terasa cepat</span>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="12-13" title='Go to the previous slide 12-13'>&larr;</div>
<div class='electure-next' data-nextid="13-1" title='Go to the next slide 13-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-13-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Akan dibutuhkan kuliah sekitar 1 jam untuk menjelaskan dengan baik kenapa versi acak dari <i>Quick Sort</i> mempunyai kompleksitas waktu yang diharapkan O(<b>N</b> log <b>N</b>) pada larik masukan <b>apapun</b> dengan <b>N</b> elemen.</p><br><p>Dalam Kuliah Maya ini, kita akan berasumsi bahwa ini benar.</p><br><p>Jika anda membutuhkan penjelasan non formal: Bayangkan bahwa versi acak dari <i>Quick Sort</i> yang mengacak pemilihan <i>pivot</i>, kita <b>tidak</b> akan selalu mendapat pembagian yang sangat jelek yaitu 0 (kosong), 1 (<i>pivot</i>), dan <b>N</b>-1 elemen lainnya. Kombinasi dari beruntung (setengah-pivot-setengah), kira-kira beruntung, kira-kira tidak beruntung, dan sangat tidak beruntung (kosong, <i>pivot</i>, sisanya) menghasilkan kompleksitas waktu rata-rata O(<b>N</b> log <b>N</b>).</p><p><br></p><p><span style="white-space: normal;">Diskusi: Untuk implementasi dari&nbsp;</span><a href="https://visualgo.net/translation/id/sorting/noshown/all/1?slide=12-4" style="white-space: normal;"><u>Partisi</u></a><span style="white-space: normal;">, apa yang terjadi jika <b>a[k] == p</b>, kita <i>selalu</i> menaruk <b>a[k]</b> pada salah satu sisi (<b>S1</b> atau <b>S2</b>) secara deterministik?</span></p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="13" title='Go to the previous slide 13'>&larr;</div>
<div class='electure-next' data-nextid="13-2" title='Go to the next slide 13-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-13-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="13-1" title='Go to the previous slide 13-1'>&larr;</div>
<div class='electure-next' data-nextid="14" title='Go to the next slide 14'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-14" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita akan membahas dua algoritma-algoritma pengurutan yang <b>tidak berbasis-pembandingan</b> di beberapa slide berikut ini:</p><ol><li><a href=""><u><i>Counting Sort</i></u></a>,</li><li><a href=""><u><i>Radix Sort</i></u></a>.</li></ol><p>Algoritma-algoritma pengurutan ini bisa lebih cepat dari batas bawah algoritma pengurutan berbasis-pembandingan yaitu Ω(<b>N</b> log <b>N</b>) karena mereka <b>tidak</b> membandingkan elemen-elemen dari larik.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="13-2" title='Go to the previous slide 13-2'>&larr;</div>
<div class='electure-next' data-nextid="14-1" title='Go to the next slide 14-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-14-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sudah diketahui (tapi tidak dibuktikan di Kuliah Maya ini karena akan membutuhkan 1 jam kuliah lagi) bahwa semua algortima pengurutan <b>berbasis-pembandingan</b> mempunyai kompleksitas waktu<b> </b>batas bawah sebesar Ω(<b>N</b> log <b>N</b>).</p><br><p>Jadi, algoritma pengurutan berbasis-pembandingan apapun dengan kompleksitas terjelek O(<b>N</b> log <b>N</b>), seperti <a href=""><u><i>Merge Sort</i></u></a> sebenarnya algoritma yang sudah optimal, kita tidak bisa berbuat lebih baik dari itu.</p><br><p>Tetapi, kita dapat mendapatkan algoritma pengurutan yang lebih cepat — yaitu dalam O(<b>N</b>) — jika ada beberapa asumsi-asumsi dari larik masukan sehingga kita dapat menghindari pembandingan dari elemen-elemen untuk menentukan urutan.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="14" title='Go to the previous slide 14'>&larr;</div>
<div class='electure-next' data-nextid="15" title='Go to the next slide 15'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-15" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><b>Asumsi</b>: Jika elemen-elemen yang akan diurutkan adalah <b>bilangan-bilangan bulat dengan <i>range</i> kecil</b>, kita dapat menghitung frekuensi dari setiap bialngan bulat (dalam <i>range</i> kecil tersebut) dan lalu mengecek range kecil tersebut untuk mengeluarkan elemen-elemen tersebut dalam urutan terurut.</p><br><p>Coba <span class="slide-actions" onclick="doButtonAction15()">Counting Sort</span> pada larik contoh diatas dimana semua bilangan-bilangan bulat berada dalam [1..9], sehingga kita hanya perlu menghitung berapa kali bilangan 1 muncul, bilangan 2 muncul, ..., bilangan 9 muncul, dan lalu mengecek 1 sampai 9 untuk mencetak <b>x</b> kopi dari bilangan <b>y</b> jika frekuensi[<b>y</b>] = <b>x</b>.</p><br><p>Kompleksitas waktunya adalah O(<b>N</b>) untuk menghitung frekuensi-frekuensi dan O(<b>N+k</b>) untuk mencetak keluaran dalam urutan terurut dimana <b>k</b> adalah <i>range</i> dari bilangan-bilangan bulat masukan, yang adalah 9-1+1 = 9 dalam contoh ini. Kompleksitas waktu dari <i>Counting Sort</i> menjadi O(<b>N+k</b>), yang adalah O(<b>N</b>) jika <b>k</b> kecil.</p><br><p>Kita tidak bisa melakukan bagian perhitungan dari <i>Counting Sort</i> ketika <b>k</b> cukup besar karena keterbatasan memori, karena kita harus menyimpan frekuensi-frekuensi dari <b>k</b> bilangan-bilangan bulat tersebut.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="14-1" title='Go to the previous slide 14-1'>&larr;</div>
<div class='electure-next' data-nextid="16" title='Go to the next slide 16'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-16" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><b>Asumsi</b>: Jika elemen-elemen yang akan diurutkan adalah <b>bilangan-bilangan bulat dengan <i>range</i> besar tetapi sedikit jumlah digit</b>, kita dapat menggabungkan ide <a href=""><u><i>Counting Sort</i></u></a> dengan <i>Radix Sort</i> untuk mencapai kompleksitas waktu linear.</p><br><p>Dalam <i>Radix Sort</i>, kita memperlakukan setiap elemen yang akan diurutkan sebagai <i>string</i> dengan <b>w</b> digit (kita tambahkan bilangan-bilangan bulat yang mempunyai kurang dari <b>w</b> digit dengan angka nol pembuka jika diperlukan).</p><br><p>Dari digit yang paling tidak signifikan (yang paling kanan) ke digit yang paling signifikan (yang paling kiri), kita melakukan satu pass ke semua <b>N</b> elemen-elemen dan menaruh mereka sesuai dengan digit aktif ke 10 Antrean (<i>Queues</i>) (satu untuk setiap digit [0..9]), yang seperti <i>Counting Sort</i> <i>termodifikasi</i> karena yang ini menjaga <a href=""><u>stabilitas</u></a>. Lalu kita menggabungkan kembali group-group tersebut untuk iterasi selanjutnya.</p><br><p>Coba <span class="slide-actions" onclick="doButtonAction16()">Radix Sort</span> pada larik masukan contoh diatas untuk penjelasan yang lebih baik.</p><br><p>Catat bahwa kita hanya melakukan O(<b>w × (N+k)</b>) iterasi. Di contoh ini, <b>w = 4</b> dan <b>k = 10</b>.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="15" title='Go to the previous slide 15'>&larr;</div>
<div class='electure-next' data-nextid="16-1" title='Go to the next slide 16-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-16-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Sekarang, setelah kita mendiskusikan <i>Radix Sort</i>, haruskah kita menggunakannya untuk <b>setiap</b> situasi pengurutan?</p><br><div>Contohnya, <i>Radix Sort</i> harusnya secara teori lebih cepat dalam mengurutkan banyak (<b>N</b> sangatlah besar) bilangan-bilangan bulat bertanda 32-bit karena <b style="white-space: normal;">w ≤ 10</b><span style="white-space: normal;">&nbsp;digit-digit dan&nbsp;</span><b style="white-space: normal;">k = 10</b><span style="white-space: normal;">&nbsp;jika kita menginterpretasikan bilangan-bilangan bulat bertanda 32-bit tersebut dalam basis Desimal. O(10 × (</span><b style="white-space: normal;">N</b><span style="white-space: normal;">+10)) = O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">).</span></div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="16" title='Go to the previous slide 16'>&larr;</div>
<div class='electure-next' data-nextid="16-2" title='Go to the next slide 16-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-16-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="16-1" title='Go to the previous slide 16-1'>&larr;</div>
<div class='electure-next' data-nextid="17" title='Go to the next slide 17'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-17" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Ada beberapa properti-properti lain yang bisa digunakan untuk membedakan algoritma-algoritma pengurutan lebih dari sekedar apakah mereka berbasis-pembandingan atau tidak, rekursif atau iteratif.</p><br><p>Dalam bagian ini, kita akan membahas tentang di-tempat dibandingkan dengan tidak di-tempat, stabil dibandingkan dengan tidak stabil, dan performa <i>caching</i> dari berbagai algoritma-algoritma pengurutan.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="16-2" title='Go to the previous slide 16-2'>&larr;</div>
<div class='electure-next' data-nextid="17-1" title='Go to the next slide 17-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-17-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sebuah algoritma pengurutan dikatakan sebagai <b>pengurutan di-tempat </b>jika algoritma tersebut hanya membutuhkan sejumlah ruang konstan (yaitu O(<b>1</b>)) selama proses pengurutan. Dengan kata lain, beberapa (konstan) variable-variable ekstra diperbolehkan tetapi kita tidak diperbolehkan untuk menggunakan variable-variable yang mempunyai ukuran tergantung kepada ukuran masukan <b>N</b>.</p><br><p><a href=""><u><i>Merge Sort</i></u></a> (versi klasik), karena sub-rutin <samp>merge</samp> nya membutuhkan larik temporer tambahan dengan ukuran <b>N</b>, tidak di-tempat.</p><br><p>Diskusi: Bagaimana dengan <i>Bubble Sort</i>, <i>Selection Sort</i>, <i>Insertion Sort</i>, <i>Quick Sort</i> (acak maupun tidak), <i>Counting Sort</i>, dan <i>Radix Sort</i>. Yang mana saja yang di-tempat?</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="17" title='Go to the previous slide 17'>&larr;</div>
<div class='electure-next' data-nextid="17-2" title='Go to the next slide 17-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-17-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sebuah algoritma pengurutan dikatakan <b>stabil </b>bila urutan relatif dari elemen-elemen <b>dengan nilai yang sama</b> tetap terpelihara oleh algoritma tersebut setelah pengurutan dilakukan.</p><br><p>Contoh aplikasi dari pengurutan stabil: Asumsikan bahwa kita memiliki nama-nama murid yang telah diurutkan secara abjad. Sekarang, jika daftar ini diurutkan lagi tetapi berdasarkan nomor grup <i>tutorial</i> (ingat bahwa satu grup <i>tutorial</i> biasanya mempunyai banyak murid-murid), sebuah algoritma pengurutan yang stabil akan menjamin bahwa semua murid-murid yang berada di dalam grup tutorial yang sama akan tetap tampil dalam urutan abjad.</p><br><p>Diskusi: Algoritma-algoritma pengurutan mana saja yang dibahas dalam Kuliah Maya ini yang stabil?<br>Cobalah mengurutkan larik A = {3, 4a, 2, 4b, 1}, lihat bahwa ada dua versi dari 4 (4a duluan, lalu 4b).</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="17-1" title='Go to the previous slide 17-1'>&larr;</div>
<div class='electure-next' data-nextid="17-3" title='Go to the next slide 17-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-17-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="17-2" title='Go to the previous slide 17-2'>&larr;</div>
<div class='electure-next' data-nextid="18" title='Go to the next slide 18'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-18" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita mendekati akhir dari Kuliah Maya ini.</p><br><p>Waktunya untuk beberapa pertanyaan-pertanyaan sederhana.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="17-3" title='Go to the previous slide 17-3'>&larr;</div>
<div class='electure-next' data-nextid="18-1" title='Go to the next slide 18-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-18-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<br><input class="mcq-answer" id="mcq-answer-1" value="5" hidden><p>Quiz: <b>Which of these algorithms run in O(N log N) on any input array of size N?</b></p><form><input type="radio" name="mcq-1-choice" value="5"> Merge Sort<br><input type="radio" name="mcq-1-choice" value="4"> Quick Sort (Deterministic)<br><input type="radio" name="mcq-1-choice" value="2"> Bubble Sort<br><input type="radio" name="mcq-1-choice" value="3"> Insertion Sort<br></form><button class="mcq-submit" id="submit-1">Submit</button> <span id="answer-status-1"></span>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="18" title='Go to the previous slide 18'>&larr;</div>
<div class='electure-next' data-nextid="18-2" title='Go to the next slide 18-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-18-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<input class="msq-answer" id="msq-answer-3" value="13,15,16" hidden><p>Quiz: <b>Which of these algorithms has worst case time complexity of Θ(N^2) for sorting N integers?</b></p><input type="checkbox" class="msq-choice" id="msq-3-choice-14"> Merge Sort<br><input type="checkbox" class="msq-choice" id="msq-3-choice-13"> Bubble Sort<br><input type="checkbox" class="msq-choice" id="msq-3-choice-16"> Selection Sort<br><input type="checkbox" class="msq-choice" id="msq-3-choice-23"> Radix Sort<br><input type="checkbox" class="msq-choice" id="msq-3-choice-15"> Insertion Sort<br><button class="msq-submit" id="submit-3">Submit</button> <span id="answer-status-3"></span><br><br><p>Θ adalah analisa kompleksitas waktu yang sudah ketat (<i>tight</i>) dimana analisa kasus terbaik Ω dan kasus terjelek big-O cocok.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="18-1" title='Go to the previous slide 18-1'>&larr;</div>
<div class='electure-next' data-nextid="19" title='Go to the next slide 19'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Kita telah mencapai akhir dari Kuliah Maya pengurutan.</p><br><p>Tetapi, masih ada dua algoritma-algoritma pengurutan lainnya di VisuAlgo yang berada didalam struktur-struktur data yang lain: <a href="./heap"><u>Heap Sort</u></a> dan <a href="./bst"><u>Balanced BST Sort</u></a>. Kita akan membahas mereka saat anda menjalani Kuliah Maya dari dua struktur-struktur data tersebut.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="18-2" title='Go to the previous slide 18-2'>&larr;</div>
<div class='electure-next' data-nextid="19-1" title='Go to the next slide 19-1'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="19" title='Go to the previous slide 19'>&larr;</div>
<div class='electure-next' data-nextid="19-2" title='Go to the next slide 19-2'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="19-1" title='Go to the previous slide 19-1'>&larr;</div>
<div class='electure-next' data-nextid="19-3" title='Go to the next slide 19-3'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sebenarnya, kode sumber C++ untuk banyak dari algoritma-algoritma pengurutan ini sudah tersebar di berbagai slide-slide Kuliah Maya. Untuk bahasa pemrograman yang lain, silahkan terjemahkan kode sumber C++ yang diberikan ke bahasa pemrograman lain tersebut.</p><br><p>Biasanya, pengurutan hanyalah bagian kecil dari proses pemecahan masalah dan akhir-akhir ini, banyak bahasa-bahasa pemrograman mempunyai fungsi-fungsi pengurutan mereka sendiri-sendiri sehingga kita tidak perlu untuk mengimplementasikan ulang algoritma-algoritma tersebut <i>kecuali sangat perlu</i>.</p><br><p>Dalam C++, anda bisa menggunakan <a href="http://en.cppreference.com/w/cpp/algorithm/sort" target="_blank"><u>std::sort</u></a> (sangat mungkin adalah algoritma pengurutan hibrid: introsort), <a href="http://en.cppreference.com/w/cpp/algorithm/stable_sort" target="_blank"><u>std::stable_sort</u></a> (sangat mungkin adalah <i>Merge Sort</i>), atau <a href="http://en.cppreference.com/w/cpp/algorithm/partial_sort" target="_blank"><u>std::partial_sort</u></a> (sangat mungkin adalah Timbunan Biner) dalam STL algorithm.<br>Dalam Python, anda bisa menggunakan <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank"><u>sort</u></a> (sangat mungkin adalah algoritma pengurutan hibrid: Timsort).<br>Dalam Java, anda bisa menggunakan <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#sort-java.util.List-" target="_blank"><u>Collections.sort</u></a>.</p><p><span style="white-space: normal;">Dalam OCaml, anda bisa menggunakan&nbsp;</span><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html" target="_blank" style="white-space: normal;"><u>List.sort compare list_name</u></a><span style="white-space: normal;">.</span><br></p><br><p>Jika fungsi pembandingan adalah spesifik ke sebuah masalah, kita mungkin harus memberikan fungsi pembandingan tambahan kepada rutin pengurutan yang sudah <i>built-in</i> tersebut.</p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="19-2" title='Go to the previous slide 19-2'>&larr;</div>
<div class='electure-next' data-nextid="19-4" title='Go to the next slide 19-4'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sekarang saatnya bagi anda untuk melihat apakah anda telah mengerti dasar-dasar dari berbagi algoritma-algoritma pengurutan yang dibahas sejauh ini.</p><br><p><span class="slide-actions" onclick="doButtonAction17()">Test your understanding here!</span></p>
<div class="electure-addition">
</div>
<div class='electure-prev' data-nextid="19-3" title='Go to the previous slide 19-3'>&larr;</div>
<div class='electure-next' data-nextid="19-5" title='Go to the next slide 19-5'>&rarr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="electure-19-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Sekarang setelah anda mencapai akhir dari Kuliah Maya ini, apakah anda pikir masalah pengurutan sesimpel pemanggilan rutin pengurutan yang sudah built-in di berbagai bahasa pemrograman?</p><br><p>Cobalah masalah-masalah di <i>online judge</i> ini untuk menyelidiki lebih lanjut:<br><a href="https://open.kattis.com/problems/mjehuric" target="_blank"><u>Kattis - mjehuric</u></a><br><a href="https://open.kattis.com/problems/sortofsorting" target="_blank"><u>Kattis - sortofsorting</u></a>, atau<br><a href="https://open.kattis.com/problems/sidewayssorting" target="_blank"><u>Kattis - sidewayssorting</u></a></p><br><p>Ini bukan akhir dari topik pengurutan. Ketika anda menjelajahi topik-topik lain di VisuAlgo, anda akan menyadari bahwa pengurutan adalah langkah <i>pre-processing</i> untuk banyak algoritma-algoritma tingkat lanjut lainnya untuk menyelesaikan masalah-masalah yang lebih sulit, contohnya sebagai langkah <i>pre-processing</i> untuk <a href="./mst"><u>algoritma Kruskal</u></a>, secara kreatif dipakai didalam struktur data <a href="./suffixarray"><u>Larik Akhiran (Suffix Array)</u></a>, dsb.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class='electure-prev' data-nextid="19-4" title='Go to the previous slide 19-4'>&larr;</div>
<div class="electure-read-status" title='Spend some more time reading this slide'>&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Tutup</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 50px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better experience</div>
<div id="widenDeviceText" style="font-size: 50px; font-weight: bold; text-align: center">Please make the window wider for a better experience</div>
</div>
<div id="sort-viz">
<svg id="viz"></svg><br>
<svg id="viz-counting-sort-secondary-canvas"></svg>
<div id="viz-radix-sort-canvas">
<span id="radix-sort-bucket-labels-collection">
<span class="radix-sort-bucket-label">0</span>
<span class="radix-sort-bucket-label">1</span>
<span class="radix-sort-bucket-label">2</span>
<span class="radix-sort-bucket-label">3</span>
<span class="radix-sort-bucket-label">4</span>
<span class="radix-sort-bucket-label">5</span>
<span class="radix-sort-bucket-label">6</span>
<span class="radix-sort-bucket-label">7</span>
<span class="radix-sort-bucket-label">8</span>
<span class="radix-sort-bucket-label">9</span>
</span>
</div>
</div>
<div id="current-action" class="panel"><p></p></div>

<style>
        .create {
            bottom: 92px
        }
    </style>
<style>
        .sort {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="create">Buat(A)</p>
<p class="execAction" id="sort" onClick="sort()">Urutkan</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="createList(&#039;random&#039;)">
<p>Acak<br></p>
</div>
<div id="create-sorted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;create&#039;, &#039;create-sorted&#039;)">
<p>Terurut</p>
<div id="create-sorted-third-tier" class="create-sorted-third-tier new-menu-option" style="display: none;">
<div id="create-sorted-non-increasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList(&#039;sorted-non-increasing&#039;)">
<p>Tidak-menaik</p>
</div>
<div id="create-sorted-non-decreasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList(&#039;sorted-non-decreasing&#039;)">
<p>Tidak-menurun</p>
</div>
</div>
</div>
<div id="create-nearly-sorted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;create&#039;, &#039;create-nearly-sorted&#039;)">
<p>Hampir terurut</p>
<div id="create-nearly-sorted-third-tier" class="create-nearly-sorted-third-tier new-menu-option" style="display: none;">
<div id="create-nearly-sorted-decreasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList(&#039;nearly-sorted-non-increasing&#039;)">
<p>Tidak-menaik</p>
</div>
<div id="create-nearly-sorted-increasing" class="execAction coloured-menu-option" style="float: right;" onClick="createList(&#039;nearly-sorted-non-decreasing&#039;)">
<p>Tidak-menurun</p>
</div>
</div>
</div>
<div id="create-many-duplicates" class="execAction new-menu-option coloured-menu-option" onClick="createList(&#039;many-duplicates&#039;)">
<p>Many Duplicates</p>
</div>
<div id="create-userdefined-input" class="new-menu-option">
A = <input id="userdefined-input" type="text" title="Enter a list of numbers, separated by commas." autocomplete="off" value="3,44,38,5,47,15,36,26,27,2,46,4,19,50,48"> </div>
<div id="create-userdefined-go" class="execAction new-menu-option coloured-menu-option" onClick="createList(&#039;userdefined&#039;)">
<p>Lakukan</p>
</div>
<div id="create-err" class="err" style="float: left;"></div>
</div>
<div class="sort action-menu-pullout">
<div id="sort-err" class="err" style="float: left;"></div>
</div>
</div>

</div>
<div id="bottom-bar">
<a id="trigger-about">Tentang</a>
<a id="trigger-team">Tim</a>
<a id="trigger-terms">Syarat Guna</a>
<a id="trigger-privacy">Kebijakan Privasi</a>
</div>
<div id="about" class="overlays">
<h4>Tentang</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>VisuAlgo digagas pada tahun 2011 oleh Dr Steven Halim sebagai alat untuk membantu murid-muridnya mengerti struktur-struktur data dan algoritma-algoritma, dengan memampukan mereka untuk mempelajari dasar-dasarnya secara otodidak dan dengan kecepatan mereka sendiri.</p><br><p>VisuAlgo mempunya banyak algoritma-algoritma tingkat lanjut yang dibahas didalam buku Dr Steven Halim (&#39;Competitive Programming&#39;, yang ditulis bersama adiknya Dr Felix Halim dan temannya Dr Suhendry Effendy) dan lebih lagi. Hari ini, beberapa dari visualisasi/animasi algoritma-algoritma tingkat lanjut ini hanya ditemukan di VisuAlgo.</p><br><p>Meskipun pada khususnya didesain untuk murid-murid National University of Singapore (NUS) yang mengambil berbagai kelas-kelas struktur data dan algoritma (contoh: CS1010/setara, CS2040/setara, CS3230, CS3233, dan CS4234), sebagai pendukung pembelajaran online, kami berharap bahwa orang-orang di berbagai belahan dunia menemukan visualisasi-visualisasi di website ini berguna bagi mereka juga.</p><br><p>VisuAlgo tidak didesain untuk layar sentuh kecil (seperti <i>smartphones</i>) dari awalnya karena kami harus membuat banyak visualisasi-visualisasi algoritma kompleks yang membutuhkan banyak <i>pixels</i> dan gestur klik-dan-tarik untuk interaksinya. Resolusi layar minimum untuk pengalaman pengguna yang lumayan adalah 1024x768 dan hanya halaman utama VisuAlgo yang secara relatif lebih ramah dengan layar kecil. Tetapi, kami sedang bereksperimen dengan versi mobil (kecil) dari VisuAlgo yang akan siap pada April 2022.</p><br><p>VisuAlgo adalah proyek yang sedang terus berlangsung dan visualisasi-visualisasi yang lebih kompleks sedang dibuat.</p><br><p>Perkembangan yang paling menarik adalah pembuatan pertanyaan otomatis (sistem kuis <i>online</i>) yang bisa dipakai oleh murid-murid untuk menguji pengetahuan mereka tentang dasar struktur-struktur data dan algoritma-algoritma. Pertanyaan-pertanyaan dibuat secara acak dengan semacam rumus dan jawaban-jawaban murid-murid dinilai secara instan setelah dikirim ke server penilai kami. Sistem kuis online ini, saat sudah diadopsi oleh banyak dosen Ilmu Komputer diseluruh dunia, seharusnya bisa menghapuskan pertanyaan-pertanyaan dasar tentang struktur data dan algoritma dari ujian-ujian di banyak Universitas. Dengan memberikan bobot kecil (tapi tidak kosong) supaya murid-murid mengerjakan kuis <i>online</i> ini, seorang dosen Ilmu Komputer dapat dengan signifikan meningkatkan penguasaan materi dari murid-muridnya tentang pertanyaan-pertanyaan dasar ini karena murid-murid mempunyai kesempatan untuk menjawab pertanyaan-pertanyaan ini yang bisa dinilai secara instan sebelum mereka mengambil kuis <i>online</i> yang resmi. Mode latihan saat ini mempunyai pertanyaan-pertanyaan untuk 12 modul visualisasi. Kami akan segera menambahkan pertanyaan-pertanyaan untuk 12 modul visualisasi yang lainnya sehingga setiap setiap modul visualisasi di VisuAlgo mempunyai komponen kuis <i>online</i>.</p><br><p>Kami telah menerjemahkan halaman-halaman VisuALgo ke tiga bahasa-bahasa utama: Inggris, Mandarin, dan Indonesia. Saat ini, kami juga telah menulis catatan-catatan publik tentang VisuAlgo dalam berbagai bahasa: <br></p>
<a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>,
<a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>,
<a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>,
<a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Tim</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Pemimpin &amp; Penasihat Proyek (Jul 2011-sekarang)</span></strong><br>
<a href='https://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='https://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid S1 Peniliti 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='https://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='https://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid S1 Peniliti 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 5 (Aug 2021-Dec 2022)</span></strong><br>
Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long
</p>
<p>
<strong><span style='line-height: 150%;'>Murid-Murid Proyek Tahun Terakhir/UROP 6 (Aug 2022-Apr 2023)</span></strong><br>
Lim Dewen Aloysius, Ting Xiao
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Ucapan Terima Kasih</span></strong><br>
Proyek ini dimungkinkan karena Hibah Pengembangan Pengajaran dari NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Syarat Guna</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>VisuAlgo is free of charge for Computer Science community on earth. If you like VisuAlgo, the only "payment" that we ask of you is for you to <b>tell the existence of VisuAlgo to other Computer Science students/instructors</b> that you know =) via Facebook/Twitter/Instagram/TikTok posts, course webpages, blog reviews, emails, etc.</p> <p>If you are a data structure and algorithm <b>student/instructor</b>, you are allowed to use this website directly for your classes. If you take screen shots (videos) from this website, you can use the screen shots (videos) elsewhere as long as you cite the URL of this website (https://visualgo.net) and/or list of publications below as reference. However, you are <b>NOT</b> allowed to download VisuAlgo (client-side) files and <b>host it</b> on your own website as it is <b>plagiarism</b>. As of now, we do <b>NOT</b> allow other people to fork this project and create variants of VisuAlgo. Using the offline copy of (client-side) VisuAlgo for your personal usage is fine.</p> <p>Note that VisuAlgo&#39;s online quiz component is by nature has heavy server-side component and there is no easy way to save the server-side scripts and databases locally. Currently, the general public can only use the &#39;training mode&#39; to access these online quiz system. Currently the &#39;test mode&#39; is a more controlled environment for using these randomly generated questions and automatic verification for&nbsp;<b>real</b> examinations in NUS.</p> <p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented briefly at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p>This work is done mostly by my past students.&nbsp;</p> <p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Dr Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Dr Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Kebijakan Privasi</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p><b>Versi 1.1 (Dimutakhirkan Jum, 14 Jan 2022).</b></p><p>Pemberitahuan kepada semua pengunjung: Kami saat ini menggunakan Google Analytics untuk mendapatkan pengertian garis besar tentang pengunjung-pengunjung situs kami. Kami sekarang memberikan opsi kepada pengguna untuk Menerima atau Menolak pelacak ini.</p><p>Sejak Rabu, 22 Des 2021, hanya staff-staff/murid-murid National University of Singapore (NUS) dan dosen-dosen Ilmu Komputer diluar dari NUS yang telah menulis kepada Steven dapat login ke VisuAlgo, orang-orang lain di dunia harus memakai VisuAlgo sebagai pengguna anonim yang tidak benar-benar terlacak selain apa yang dilacak oleh Google Analytics.</p><p>Untuk murid-murid NUS yang mengambil mata kuliah yang menggunakan VisuAlgo: Dengan menggunakan akun VisuAlgo (sebuah tupel dari alamat email NUS resmi, nama murid resmi NUS seperti dalam daftar kelas, dan sebuah kata sandi yang dienkripsi pada sisi server — tidak ada data personal lainnya yang disimpan), anda memberikan ijin kepada dosen modul anda untuk melacak pembacaan slide-slide kuliah maya dan kemajuan latihan kuis online yang dibutuhkan untuk menjalankan modul tersebut dengan lancar. Akun VisuAlgo anda akan juga dibutuhkan untuk mengambil kuis-kuis VisuAlgo online resmi sehingga memberikan kredensial akun anda ke orang lain untuk mengerjakan Kuis Online sebagai anda adalah pelanggaran akademis.. Akun pengguna anda akan dihapus setelah modul tersebut selesai kecuali anda memilih untuk menyimpan akun anda (OPT-IN). Akses ke basis data lengkap dari VisuAlgo (dengan kata-kata sandi terenkripsi) dibatasi kepada Steven saja.</p><p>Untuk murid-murid NUS lainnya, anda dapat mendaftarkan sendiri sebuah akun VisuAlgo (OPT-IN).</p><p>Untuk dosen-dosen Ilmu Komputer di seluruh dunia yang telah menulis kepada Steven, sebuah akun VisuAlgo (alamat email (bukan-NUS), anda dapat menggunakan nama panggilan apapun, dan kata sandi terenkripsi) dibutuhkan untuk membedakan kredensial online anda dibandingkan dengan orang-orang lain di dunia. Akun anda akan dilacak seperti seorang murid NUS biasa diatas tetapi akun anda akan mempunya fitur-fiture spesifik untuk dosen-dosen Ilmu Komputer, yaitu kemampuan untuk melihat slide-slide tersembunyi yang berisi jawaban-jawaban (menarik) dari pertanyaan-pertanyaan yang dipresentasikan di slide-slide sebelumnya sebelum slide-slide tersembunyi tersebut. Anda juga dapat mengakses setingan Susah dari Kuis-Kuis Online VisuAlgo. Anda dapat dengan bebas menggunakan materi-materia untuk memperkaya kelas-kelas struktur-struktur data dan algoritma-algoritma anda. Catatan: Mungkin ada fitur-fitur khusus tambahan untuk dosen Ilmu Komputer di masa mendatang.</p><p>Untuk siapapun dengan akun VisuAlgo, anda dapat membuang akun anda sendiri bila anda tidak mau lagi diasosiasikan dengan tool VisuAlgo ini.</p>
</div>
</div>
</div>


<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
    });
  })
</script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "MEOOXmYvzYv6CeBn1Y6tWoV3KTNyFF458dJojBxk"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // var PHP_DOMAIN = ""; // is this still used? I turn it off on 4 Jan 2022, see if causes issue

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
//console.log(variable + " : " + pair[0] + " -> " + pair[1]);
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not. 
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
// test drop on 4 Jan 2022, see if got issues
      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }
*/

      // big question mark on 4 Jan 2022: should I drop this GA for a better privacy policy?

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      function setCookie(cname, cvalue, exdays) {
        const d = new Date();
        d.setTime(d.getTime() + (exdays*24*60*60*1000));
        let expires = "expires="+ d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      }

              $(function () {
          ga('create', 'UA-1566631-4', 'auto');
          ga('send', 'pageview');
        })
      
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="https://visualgo.net/js/jquery-ui.min.js"></script>

<script src="https://visualgo.net/js/d3.min.js"></script>
<script src="https://visualgo.net/js/viz-1.0.6.js"></script>


<script src="/js/graph_library-1.0.8.js"></script>
<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() { 
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":75,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":1,"showCodetracePanel":0,"created_at":"2017-02-12 21:12:52","updated_at":"2022-01-04 08:38:11","section":-1,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.bubbleSort, \"29,10,14,37,14\");","section_order":-1,"value":"1","text":"<p>Pengurutan adalah masalah klasik tentang mengubah urutan elemen-elemen (yang bisa dibandingkan, seperti bilangan bulat, bilangan pecahan, <i>strings<\/i>, dsb) dari sebuah larik (senarai) ke urutan tertentu (menaik, tidak-menurun (menaik atau datar), menurun, tidak-menaik (menurun atau datar), terurut secara abjad, dsb).<\/p><br><p>Ada banyak algoritma-algoritma pengurutan, dan masing-masing memiliki kekuatan-kekuatan maupun kekurangan-kekurangan.<br><\/p><p><br><\/p><div><p>Pengurutan biasanya digunakan sebagai masalah pembuka dalam berbagai kelas-kelas Ilmu Komputer untuk menjelaskan berbagai ide-ide algoritma.<\/p><br><p>Tanpa kehilangan makna umum, kami menggunakan asumsi bahwa kita akan mengurutkan hanya <b>bilangan-bilangan bulat<\/b>, tidak harus unik, ke dalam <b>urutan tidak-menurun<\/b> di visualisasi ini. Cobalah klik <span class=\"slide-actions\" onclick=\"doButtonAction11()\">Bubble Sort<\/span> untuk animasi contoh pengurutan daftar 5 bilangan-bilangan bulat yang tidak beratur (dengan duplikat) diatas.<\/p><\/div>","title":"Masalah dan Algoritma Pengurutan"},{"id":541,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-31 08:07:04","updated_at":"2022-03-16 13:00:45","section":75,"code":"","section_order":1,"value":"1-1","text":"<p>Sorting problem has a variety of interesting algorithmic solutions that embody many Computer Science ideas:<\/p><ol><li><a href=\"?slide=5\"><u>Comparison<\/u><\/a> versus <a href=\"?slide=14\"><u>non-comparison<\/u><\/a> based strategies,<\/li><li>Iterative versus Recursive implementation,<\/li><li>Divide-and-Conquer paradigm (e.g., <a href=\"?slide=11-4\"><u>Merge Sort<\/u><\/a> or <a href=\"?slide=12-1\"><u>Quick Sort<\/u><\/a>),<\/li><li>Best\/Worst\/Average-case Time Complexity analysis,<\/li><li><a href=\"?slide=13\"><u>Randomized Algorithms<\/u><\/a>, etc.<\/li><\/ol>","title":"Motivasi - Ide-Ide Menarik Info Komputer"},{"id":542,"category":"sorting","order":2,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-31 08:10:32","updated_at":"2022-01-04 13:03:58","section":75,"code":"","section_order":1,"value":"1-2","text":"<p>Ketika sebuah larik (bilangan bulat) <b>A<\/b> terurut, banyak masalah-masalah yang berhubungan dengan <b>A<\/b> menjadi mudah (atau lebih mudah):<\/p><ol><li>Mencari nilai spesifik <b>v<\/b> di dalam larik <b>A<\/b>,<\/li><li>Mencari nilai terkecil\/terbesar atau nilai terkecil\/terbesar ke-k di larik (statis) <b>A<\/b>,<\/li><li>Mengetes keunikan dan menghapus duplikat dari larik <b>A<\/b>,<\/li><li>Menghitung seberapa banyak nilai spesifik <b>v<\/b> muncul dalam larik <b>A<\/b>,<\/li><li>Himpunan Irisan\/Gabungan dari larik <b>A<\/b> dan larik terurut lainnya yaitu <b>B<\/b>,<\/li><li>Mencari pasangan target <b>x<\/b> \u2208 <b>A<\/b> dan <b>y<\/b> \u2208 <b>A<\/b> sehingga <b>x+y<\/b> sama dengan nilai target <b>z<\/b>,<\/li><li>Menghitung banyak nilai di larik <b>A<\/b>&nbsp;yang berada pada jangkauan [<b>lo<\/b>..<b>hi<\/b>], dsb.<\/li><\/ol><p>Diskusi: Dalam kelas-kelas nyata, instruktor bisa membahas aplikasi-aplikasi ini dengan lebih detail.<\/p>","title":"Motivasi - Aplikasi-Aplikasi"},{"id":769,"category":"sorting","order":3,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2021-12-26 14:14:40","updated_at":"2022-01-04 13:04:43","section":75,"code":"","section_order":1,"value":"1-3","text":"<ol><li>Kita bisa menggunakan O(log <b>N<\/b>) pencarian biner pada sebuah larik terurut,<\/li><li>A[0]\/A[k-1]\/A[N-k]\/A[N-1] adalah yang nilai terkecil\/k-terkecil\/k-terbesar\/terbesar di larik <b>A<\/b> (terurut statis),<\/li><li>Duplikat-duplikat, jika ada, akan bersebelahan di larik terurut <b>A<\/b>,<\/li><li>Sama seperti diatas,<\/li><li>Kita bisa menggunakan modifikasi dari rutin <i>merge<\/i> dari <i>Merge Sort<\/i>,<\/li><li>Kita bisa menggunakan metode dua penunjuk-penunjuk,<\/li><li>Indeks dari <b>y<\/b> - indeks dari <b>x<\/b> + 1 (menggunakan dua pencarian-pencarian biner).<\/li><\/ol><p>Ada cara-cara lainnya.<\/p>","title":"Beberapa Petunjuk-Petunjuk"},{"id":78,"category":"sorting","order":2,"top":"","right":"","bottom":"140px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-13 04:46:36","updated_at":"2022-01-04 13:27:08","section":-1,"code":"$(\"#create\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"2","text":"<p>Ada dua aksi yang anda dapat lakukan di visualisasi ini.<\/p>","title":"Aksi-Aksi"},{"id":544,"category":"sorting","order":1,"top":"","right":"","bottom":"140px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 04:43:12","updated_at":"2022-02-02 13:59:19","section":78,"code":"$(\"#create\").click().addClass(\"menu-highlighted\");","section_order":2,"value":"2-1","text":"<p>Aksi pertama adalah tentang mendefinisikan masukan <b>anda sendiri<\/b>, sebuah larik\/daftar <b>A<\/b> yang:<\/p><ol><li>Betul-betul acak,<\/li><li>Acak tapi terurut (dalam urutan tidak-menurun atau tidak-menaik),<\/li><li>Acak tetapi <b>hampir<\/b> terurut (dalam urutan tidak-menurun atau tidak-menaik),<\/li><li>Acak dan memiliki banyak duplikat-duplikat (sehingga jangkauan bilangan-bilangan bulatnya kecil), atau<\/li><li>Didefinisikan oleh anda sendiri.<\/li><\/ol><p>Dalam mode Eksplorasi, anda dapat bereksperimen dengan berbagai algoritma-algoritma pengurutan yang tersedia di visualisasi ini untuk mengetahui masukan-masukan terbaik dan terjelek untuk algoritma-algoritma tersebut.<\/p>","title":"Masukkan Input Anda Sendiri"},{"id":545,"category":"sorting","order":2,"top":"","right":"","bottom":"140px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 04:45:26","updated_at":"2022-01-05 02:18:17","section":78,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");","section_order":2,"value":"2-2","text":"<p>Aksi kedua adalah yang terpenting: Jalankan algoritma pengurutan yang sedang aktif dengan meng-klik tombol \"Urutkan\".<\/p><br><p>Ingat bahwa anda dapat mengubah algoritma yang aktif dengan meng-klik <a href=\"?slide=4-1\"><u>singkatan<\/u><\/a> di sisi atas dari halaman visualisasi ini.<\/p>","title":"Jalankan Algoritma Pengurutan Terpilih"},{"id":77,"category":"sorting","order":3,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-13 04:45:18","updated_at":"2022-01-05 02:19:29","section":-1,"code":"","section_order":-1,"value":"3","text":"<p>Lihat visualisasi\/animasi dari algoritma pengurutan terpilih disini.<\/p><p><br><\/p><p>Tanpa kehilangan makna umum, kami hanya menunjukkan bilangan-bilangan bulat didalam visualisasi ini dan tujuan kami adalah untuk mengurutkan mereka dari status awal ke status terurut tidak-menurun. Ingat, tidak-menurun berarti pada umumnya urutan menaik (atau membesar), tetapi karena bisa ada duplikat-duplikat, bisa ada garis datar\/sama diantara dua bilangan-bilangan bulat bersisian yang bernilai sama.<\/p>","title":"Visualisasi"},{"id":76,"category":"sorting","order":4,"top":"60px","right":"","bottom":"","left":"220px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-12 21:53:26","updated_at":"2022-01-04 14:01:01","section":-1,"code":"","section_order":-1,"value":"4","text":"<p>Di bagian atas halaman ini, anda akan melihat daftar berbagai algoritma-algoritma pengurutan yang biasanya diajarkan dalam kelas-kelas Ilmu Komputer. Untuk mengaktifkan algoritma tertentu, pilihlah <a href=\"?slide=4-1\"><u>singkatan<\/u><\/a> dari nama algoritma yang bersangkutan sebelum meng-klik \"Urutkan\".<\/p><div><br><p>Untuk memfasilitasi keberagaman, kami akan mengacak algoritma yang aktif setiap kali halaman ini ditampilkan.<\/p><br><p>Enam algoritma pertama adalah <b>berbasis-pembandingan<\/b> sedangkan dua terakhir tidak. Kita akan membahas ide ini <a href=\"?slide=13\"><u>di pertengahan<\/u><\/a> Kuliah Maya ini.<\/p><br><p>Tiga algoritma ditengah adalah algoritma pengurutan yang bersifat <b>rekursif <\/b>sedangkan sisanya biasa diimplementasikan secara iteratif.<\/p><\/div>","title":"Algoritma-Algoritma Pengurutan Umum"},{"id":540,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"220px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-31 07:14:49","updated_at":"2017-05-31 07:15:06","section":76,"code":"","section_order":4,"value":"4-1","text":"<p>Supaya muat di layar, kami menyingkat nama-nama algoritma menjadi tiga karakter saja:<\/p><ol><li>Algoritma-Algorithma Pengurutan berbasis-pembandingan:<ol><li>BUB - <i>Bubble Sort<\/i>,<\/li><li>SEL - <i>Selection Sort<\/i>,<\/li><li>INS - <i>Insertion Sort<\/i>,<\/li><li>MER - <i>Merge Sort<\/i> (implementasi rekursif),<\/li><li>QUI - <i>Quick Sort<\/i> (implementasi rekursif),<\/li><li>R-Q - <i>Quick Sort<\/i> Acak (implementasi rekursif).<\/li><\/ol><\/li><li>Algoritma-Algoritma Pengurutan tidak berbasis-pembandingan:<ol><li>COU - <i>Counting Sort<\/i>,<\/li><li>RAD - <i>Radix Sort<\/i>.<\/li><\/ol><\/li><\/ol>","title":"Singkatan-Singkatan"},{"id":554,"category":"sorting","order":5,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:05:09","updated_at":"2017-06-01 07:05:14","section":-1,"code":"","section_order":-1,"value":"5","text":"<p>Kita akan membahas tiga algoritma-algoritma pengurutan berbasis-pembandingan di beberapa slides berikutnya:<\/p><ol><li><a href=\"?slide=6\"><u><i>Bubble Sort<\/i><\/u><\/a>,<\/li><li><a href=\"?slide=7\"><u><i>Selection Sort<\/i><\/u><\/a>,<\/li><li><a href=\"?slide=8\"><u><i>Insertion Sort<\/i><\/u><\/a>.<\/li><\/ol><p>Mereka disebut <b>berbasis-pembandingan<\/b> karena mereka membandingkan pasangan elemen-elemen dari sebuah larik dan menentukan apakah akan menukar posisi mereka atau tidak.<\/p><br><p>Ketiga algoritma-algoritma pengurutan ini adalah yang termudah untuk diimplementasikan tetapi juga bukan yang paling efisien, karena mereka berjalan dalam kompleksitas waktu O(<b>N<\/b><sup>2<\/sup>).<\/p>","title":"3 O(N^2) Algoritma Berbasis-Pembandingan"},{"id":735,"category":"sorting","order":6,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:41:02","updated_at":"2022-01-04 14:03:09","section":-1,"code":"","section_order":-1,"value":"6","text":"<p>Sebelum kita memulai diskusi berbagai algoritma-algoritma pengurutan, adalah ide bagus untuk membahas dasar-dasar dari analisa algoritma secara asimptotik, sehingga anda dapat mengikuti diskusi-diskusi dari berbagai algoritma-algoritma pengurutan O(<b>N<\/b>^2), O(<b>N<\/b> log <b>N<\/b>), dan spesial O(<b>N<\/b>) nantinya.<\/p><br><p><i>Section<\/i> ini bisa dilompati jika anda sudah mengetahui topik ini.<\/p>","title":"(Dasar) Analisa Algoritma-Algoritma"},{"id":736,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:43:03","updated_at":"2020-10-06 04:43:03","section":735,"code":"","section_order":6,"value":"6-1","text":"<p>Anda butuh untuk sudah mengerti\/mengingat hal-hal ini:<br>-. Logaritma dan Eksponen, misalkan log<sub>2<\/sub>(1024) = 10, 2<sup>10<\/sup> = 1024<br>-. Deret Aritmetika, misalkan 1+2+3+4+\u2026+10 = 10*11\/2 = 55<br>-. Deret Geometri, misalkan 1+2+4+8+..+1024 = 1*(1-2<sup>11<\/sup>)\/(1-2) = 2047<br>-. Fungsi Linear\/Kuadratik\/Kubik, misalkan f1(x) = x+2, f2(x) = x<sup>2<\/sup>+x-1, f3(x) = x<sup>3<\/sup>+2x<sup>2<\/sup>-x+7<br>-. Fungsi Langit-Langit, Lantai, dan Absolut, misalkan ceil(3.1) = 4, floor(3.1) = 3, abs(-7) = 7<\/p>","title":"Prasyarat Matematik"},{"id":737,"category":"sorting","order":2,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:47:21","updated_at":"2020-10-06 04:47:21","section":735,"code":"","section_order":6,"value":"6-2","text":"<p>Analisis algoritma adalah sebuah proses untuk mengevaluasi secara keras sumber daya (waktu dan ruang) yang dibutuhkan oleh sebuah algoritma dan merepresentasikan hasil dari evaluasi tersebut dengan sebuah formula (sederhana).<\/p><br><p>Kebutuhan waktu\/ruang dari sebuah algoritma juga disebut sebagai kompleksitas waktu\/ruang dari algoritma tersebut, masing-masing.<\/p><br><p>Untuk modul ini, kita lebih memfokuskan kepada persyaratan waktu dari berbagai algoritma-algoritma pengurutan.<\/p>","title":"Apa Itu?"},{"id":738,"category":"sorting","order":3,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:49:12","updated_at":"2021-12-26 14:22:25","section":735,"code":"","section_order":6,"value":"6-3","text":"<p>Kita bisa mengukur waktu perjalanan aktual dari sebuah program dengan menggunakan waktu jam dinding atau dengan memasukkan kode pengukuran-waktu kedalam program kita, misalkan lihat kode yang ditunjukkan didalam <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.cpp\" target=\"_blank\"><u>SpeedTest.cpp<\/u><\/a> | <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.java\" target=\"_blank\"><u>java<\/u><\/a>.<\/p><br><p>Tetapi, waktu perjalanan aktual tidak berarti banyak ketika membandingan dua algoritma-algoritma karena mereka mungkin ditulis dalam bahasa-bahasa yang berbeda, menggunakan set-set data yang berbeda, atau berjalan pada komputer-komputer yang berbeda.<\/p>","title":"Mengukur Waktu Runtime Sesungguhnya?"},{"id":739,"category":"sorting","order":4,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:53:49","updated_at":"2021-12-26 14:22:51","section":735,"code":"","section_order":6,"value":"6-4","text":"<p>Daripada mengukur waktu sebenarnya, kita bisa menghitung # dari operasi-operasi (aritmetik, penugasan, pembandingan, dsb). Ini adalah cara untuk mengukur efesiensi karena waktu eksekusi dari sebuah algoritma terkorelasi dengan # operasi-operasi yang dibutuhkannya.<\/p><br><p>Lihat kode yang ditunjukkan di <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.cpp\" target=\"_blank\"><u>SpeedTest.cpp<\/u><\/a> | <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/SpeedTest.java\" target=\"_blank\"><u>java<\/u><\/a> dan komentar-komentarnya (terutama tentang bagaimana mendapatkan nilai final dari variabel <i>counter<\/i>).<\/p><br><p>Mengetahu jumlah operasi-operasi (persis) yang dibutuhkan oleh sebuah algoritma, kita bisa menyatakan sesuatu seperti ini: Algoritma <b>X<\/b> membutuhkan <b>2n<sup>2<\/sup> + 100n<\/b> operasi-operasi untuk menyelesaikan masalah dengan ukuran <b>n<\/b>.<\/p>","title":"Menghitung # Operasi (1)"},{"id":740,"category":"sorting","order":5,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:55:58","updated_at":"2020-10-06 04:55:58","section":735,"code":"","section_order":6,"value":"6-5","text":"<p>Jika waktu <b>t<\/b> yang dibutuhkan untuk sebuah operasi diketahu, maka kita bisa menyatakan bahwa algoritma <b>X<\/b> membutuhkan <b>(2n<sup>2<\/sup> + 100n)t<\/b> unit-unit waktu untuk menyelesaikan masalah dengan ukuran <b>n<\/b>.<\/p><br><p>Tetapi, waktu <b>t<\/b> tergantung dari faktor-faktor yang disebut sebelumnya, misalkan bahasa-bahasa, kompiler-kompiler, dan komputer-komputer yang berbeda, dsb.<\/p><br><p>Oleh karena itu, daripada menghubungkan analisa ke waktu <b>t<\/b> yang sebenarnya, kita bisa menyatakan bahwa algoritma <b>X<\/b> membutuhkan waktu yang <b>proporsional terhadap 2n<sup>2<\/sup> + 100n<\/b> untuk menyelesaikan masalah dengan ukuran <b>n<\/b>.<\/p>","title":"Menghitung # Operasi (2)<br>"},{"id":741,"category":"sorting","order":6,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 04:58:45","updated_at":"2020-10-06 04:58:45","section":735,"code":"","section_order":6,"value":"6-6","text":"<p>Analisa Asimtotik adalah sebuah analisa algoritma-algoritma yang berfokus pada penganalisaan masalah-masalah dengan <b>ukuran masukan n yang besar<\/b>, memikirkan hanya <b>term tertinggi saja <\/b>dari formula, dan <b>mengabaikan koefisien <\/b>dari term tertinggi.<\/p><br><p>Kita memilih term tertinggi karena term-term yang lebih kecil berkontribusi lebih sedikit kepada biaya total saat ukuran masukan bertumbuh besar, misalkan untuk f(n) = 2n<sup>2<\/sup> + 100n, kita punya:<br>f(1000) = 2*1000<sup>2<\/sup> + 100*1000 = 2.1M, versus<br>f(100000) = 2*100000<sup>2<\/sup> + 100*100000 = 20010M.<br>(sadari bahwa term yang lebih kecil 100n memiliki kontribusi yang lebih kecil).<\/p>","title":"Analisa <i>Asymptotic<\/i>"},{"id":742,"category":"sorting","order":7,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 05:04:16","updated_at":"2020-10-06 05:04:16","section":735,"code":"","section_order":6,"value":"6-7","text":"<p>Misalkan dua algoritma-algoritma memiliki 2n<sup>2<\/sup> dan 30n<sup>2<\/sup> sebagai term-term tertinggi.<\/p><br><p>Meskipun waktu sebenarnya akan berbeda karena konstanta-konstanta yang berbeda, laju-laju pertumbuhan dari waktu eksekusi adalah sama.<\/p><br><p>Dibandingkan dengan algoritma lain dengan term tertinggi n<sup>3<\/sup>, perbedaan dari laju pertumbuhan adalah faktor yang jauh lebih dominan.<\/p><br><p>Maka, kita bisa melepaskan koefisien dari term tertinggi ketika mempelajari kompleksitas algoritma.<\/p>","title":"Mengabaikan Koefisien dari Term Paling Depan"},{"id":743,"category":"sorting","order":8,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 05:06:54","updated_at":"2020-10-06 05:06:54","section":735,"code":"","section_order":6,"value":"6-8","text":"<p>Jika algoritma A membutuhkan waktu proporsional terhadap <b>f(n)<\/b>, kita bilang bahwa algoritma A berada dalam order f(n).<\/p><br><p>Kita menulis bahwa algoritma A mempunyai kompleksitas waktu <b>O(f(n))<\/b>, dimana <b>f(n)<\/b> adalah fungsi laju pertumbuhan untuk algoritma A.<\/p>","title":"Batas Atas: Notasi Big-O"},{"id":746,"category":"sorting","order":9,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 05:19:30","updated_at":"2022-01-31 15:17:25","section":735,"code":"","section_order":6,"value":"6-9","text":"<p>Secara matematis, sebuah algoritma adalah O(<b>f(n)<\/b>) jika ada sebuah konstanta <b>k<\/b> dan sebuah bilangan bulat positif <b>n0<\/b> sehingga algoritma A membutuhkan tidak lebih dari <b>k*f(n)<\/b> unit-unit waktu untuk menyelesaikan sebuah masalah dengan ukuran <b>n \u2265 n0<\/b>, yaitu, jika ukuran masalah lebih besari dari <b>n0<\/b>, algoritma A (selalu) dibatasi dari atas oleh formula sederhana <b>k*f(n)<\/b> ini.<\/p><br><center><img src=\"https:\/\/visualgo.net\/img\/big_O_notation.png\" width=\"300\" alt=\"Big-O Notation\"><\/center><br><p>Catat bahwa: <b>n0<\/b> dan <b>k<\/b> tidak unik dan bisa ada beberapa banyak <b>f(n)<\/b> valid yang memungkinkan.<\/p>","title":"Notasi Big-O (Matematik)"},{"id":744,"category":"sorting","order":10,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 05:08:38","updated_at":"2022-01-04 14:07:15","section":735,"code":"","section_order":6,"value":"6-10","text":"<p>Dalam analisa asimtotik, sebuah formula bisa disederhanakan menjadi sebuah term tunggal dengan koefisien 1.<\/p><br><p>Term tersebut disebut sebagai term pertumbuhan (tingkat pertumbuhan, urutan pertumbuhan, urutan besar).<\/p><br><p>Term-term pertumbuhan yang paling umum dapat diurutkan dari yang paling cepat ke paling lambat sebagai berikut:<br>O(<b>1<\/b>)\/waktu konstan &lt; O(log <b>n<\/b>)\/waktu logaritmik &lt; O(<b>n<\/b>)\/waktu linear &lt;<br>O(<b>n<\/b> log <b>n<\/b>)\/waktu kuasilinear &lt; O(<b>n<\/b><sup>2<\/sup>)\/waktu kuadratik &lt; O(<b>n<\/b><sup>3<\/sup>)\/waktu kubik &lt;<br>O(2<sup><b>n<\/b><\/sup>)\/waktu eksponensial &lt; O(<b>n<\/b>!)\/waktu juga-eksponensial &lt; \u221e (misalkan, perulangan tak berakhir).<\/p><br><p>Catat bahwa ada beberapa kompleksitas-kompleksitas waktu yang umum lainnya yang tidak ditunjukkan (lihat juga visualisasi di slide berikutnya)).<\/p>","title":"Term-Term Pertumbuhan"},{"id":745,"category":"sorting","order":11,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-10-06 05:15:27","updated_at":"2020-10-06 05:19:44","section":735,"code":"","section_order":6,"value":"6-11","text":"<img src=\"https:\/\/visualgo.net\/img\/growth_rates.png\" width=\"500\" alt=\"Common Growth Terms\"><br><p>Kita akan melihat tiga laju-laju pertumbuhan yang berbeda O(<b>n<sup>2<\/sup><\/b>), O(<b>n log n<\/b>), dan O(<b>n<\/b>) sepanjang sisa dari modul pengurutan ini.<\/p>","title":"Term-Term Pertumbuhan (Divisualisasikan\/Dibandingkan)<br>"},{"id":175,"category":"sorting","order":7,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 15:14:08","updated_at":"2022-01-04 14:08:38","section":-1,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.bubbleSort, \"29,10,14,37,14\");","section_order":-1,"value":"7","text":"Diberikan sebuah larik berisi <b>N<\/b> elemen-elemen, <i>Bubble Sort<\/i> akan:<div><ol><li><b>Membandingkan<\/b> pasangan yang bersebelahan (a, b),<\/li><li>Menukar pasangan tersebut bila tidak pada urutan yang seharusnya (dalam kasus ini, ketika a &gt; b),<\/li><li>Ulangi Langkah 1 dan 2 hingga kita sampai di akhir larik<br>(pasangan terakhir adalah elemen ke (<b>N<\/b>-2) dan (<b>N<\/b>-1) karena kita menggunakan indeks basis-0),<\/li><li>Pada saat ini, elemen terbesar akan terletak pada posisi terakhir.<br>Kita lalu mengurangi <b>N<\/b> dengan 1 dan kembali ke Langkah 1 sampai kita mendapat <b>N = 1<\/b>.<\/li><\/ol><\/div><p><span style=\"text-align: center;\">Tanpa basa-basi lagi, mari coba <span class=\"slide-actions\" onclick=\"doButtonAction11()\">Bubble Sort<\/span> pada larik contoh kecil [29, 10, 14, 37, 14].<\/span><\/p><p><br><\/p><p>Anda akan melihat animasi &#39;seperti-gelembung&#39; jika anda membayangkan elemen-elemen yang besar &#39;menggelembung keatas&#39; (atau sebenarnya &#39;bergerak ke sisi kanan dari larik&#39;).<br><\/p>","title":"Bubble Sort"},{"id":206,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:36:47","updated_at":"2022-01-05 08:33:05","section":175,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.bubbleSort, \"29,10,14,37,14\");","section_order":7,"value":"7-1","text":"<pre>void bubbleSort(int a[], int N) { \/\/ versi standar<br>  for (; N &gt; 0; --N) \/\/ N iterasi-iterasi<br>    for (int i = 0; i &lt; N-1; ++i) \/\/ kecuali terakhir, O(N)<br>      if (a[i] &gt; a[i+1]) \/\/ tidak dalam urutan tidak-menurun<br>        swap(a[i], a[i+1]); \/\/ tukar dalam O(1)<br>}<br><\/pre><p>Pembandingan dan penukaran membutuhkan waktu yang dibatasi oleh sebuah konstanta, mari sebut saja dengan <b>c<\/b>. Lalu, ada dua perulangan (<i>loop<\/i>) yang bertingkat (<i>nested<\/i>) dalam <i>Bubble Sort<\/i> standar. Perulangan<i> <\/i>(<i>loop<\/i>) luar berjalan tepat sebanyak <b>N<\/b> iterasi. Tetapi pengulangan (loop) dalam menjadi sedikit lebih pendek pada setiap iterasi:<\/p><ol><li>Saat i=0, (<b>N<\/b>\u22121) iterasi (dari pembandingan-pembandingan dan kemungkinan pertukaran-pertukaran),<\/li><li>Saat i=1, (<b>N<\/b>\u22122) iterasi,<br>...,<\/li><li>Saat i=(<b>N<\/b>\u22122), 1 iterasi,<\/li><li>Saat i=(<b>N<\/b>\u22121), 0 iterasi.<\/li><\/ol><p>Sehingga, jumlah total dari iterasi = (<b>N<\/b>\u22121)+(<b>N<\/b>\u22122)+...+1+0 = <b>N<\/b>*(<b>N<\/b>\u22121)\/2 (<a href=\"https:\/\/en.wikipedia.org\/wiki\/Arithmetic_progression#Sum\" target=\"_blank\"><u>penurunan<\/u><\/a>)<br>Waktu total adalah = c*<b>N<\/b>*(<b>N<\/b>\u22121)\/2 = O(<b>N<\/b>^2)<\/p>","title":"Bubble Sort: Kode C++ dan Analisa"},{"id":207,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:39:59","updated_at":"2022-01-04 14:10:17","section":175,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.bubbleSort, \"3,6,11,25,39\");","section_order":7,"value":"7-2","text":"<p><i>Bubble Sort<\/i> sebenarnya tidak efisien dengan kompleksitas waktu <b>O(N^2)<\/b>. Bayangkan jika kita memiliki <b>N<\/b> = 10<sup>5<\/sup> angka-angka. Meskipun komputer kita sangat cepat dan dapat menghitung 10<sup>8<\/sup> operasi-operasi dalam 1 detik, <i>Bubble Sort<\/i> akan membutuhkan sekitar 100 detik untuk menyelesaikan tugas ini.<\/p><p><br><\/p><p>Tetapi, <i>Bubble Sort<\/i> dapat dihentikan lebih awal, misalkan pada contoh kecil yang telah terurut menaik diatas <span style=\"white-space: normal;\">[3, 6, 11, 25, 39],&nbsp;<\/span><span class=\"slide-actions\" onclick=\"doButtonAction11()\">Bubble Sort<\/span> dapat dihentikan dalam waktu O(<b>N<\/b>).<\/p><br><p>Idenya mudah: Jika kita melalui perulangan dalam (<i>inner loop<\/i>) <b>tanpa melakukan pertukaran<\/b> sama sekali, itu berarti bahwa larik tersebut <b>sudah terurut<\/b> dan kita dapat menghentikan <i>Bubble Sort<\/i> pada saat itu.<\/p><br><p>Diskusi: Meskipun ide tersebut membuat <i>Bubble Sort<\/i> berjalan lebih cepat dalam kasus-kasus umum, ide ini tidak mengubah kompleksitas waktu <b>O(N^2)<\/b> dari <i>Bubble Sort<\/i>... Kenapa?<\/p>","title":"Bubble Sort: Diberhentikan Lebih Awal"},{"id":543,"category":"sorting","order":3,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-31 09:26:35","updated_at":"2022-02-02 14:10:41","section":175,"code":"$('#title-Bubble').click();\n$(\"#sort\").addClass(\"menu-highlighted\");","section_order":7,"value":"7-3","text":"<p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction33()\">Bubble Sort Extreme Case<\/span> dimana kita menjalankan <i>Bubble Sort<\/i> pada sebuah larik masukan kecil yang terurut terbalik. Kita akan menjumpai kompleksitas waktu O(<b>N<\/b><sup>2<\/sup>) lagi.<\/p><p><br><\/p><p style=\"white-space: normal;\">Catat bahwa menjalankan <i>Bubble Sort<\/i> pada larik yang `hampir terurut&#39; seperti [2,3,4,5,6,...,1] juka akan membuah <i>Bubble Sort<\/i> teroptimisasi tetap berjalan dalam O(<b>N<\/b><sup>2<\/sup>).<br><\/p>","title":"Jawaban"},{"id":176,"category":"sorting","order":8,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 15:26:17","updated_at":"2022-01-04 14:12:52","section":-1,"code":"$('#title-Selection').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.selectionSort, \"29,10,14,37,13\");","section_order":-1,"value":"8","text":"<p>Diberikan sebuah larik berisi <b>N<\/b> elemen dan <b>L<\/b> = 0, <i>Selection Sort<\/i> akan:<br><\/p><ol><li>Menemukan posisi <b>X<\/b> dari elemen terkecil dalam interval [<b>L...N<\/b>-1],<\/li><li>Tukar item ke-<b>X<\/b> dengan item ke-<b>L<\/b>,<\/li><li>Naikkan batas bawah <b>L<\/b> sebesar 1 dan kembail ke Langkah 1 sampai <b>L<\/b> = <b>N<\/b>-2.<br><\/li><\/ol><p>Mari coba <span class=\"slide-actions\" onclick=\"doButtonAction8()\">Selection Sort<\/span> pada larik contoh kecil yang sama <span style=\"white-space: normal;\">[29, 10, 14, 37, 13]<\/span>.<\/p><br><p>Tanpa kehilangan makna umum, kita juga dapat mengimplementasikan <i>Selection Sort<\/i> secara terbalik:<br>Temukan posisi dari elemen terbesar <b>Y<\/b> dan tukar dengan elemen terakhir.<\/p>","title":"Selection Sort"},{"id":187,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 20:35:19","updated_at":"2022-02-08 05:58:05","section":176,"code":"$('#title-Selection').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.selectionSort, \"29,10,14,37,13\");","section_order":8,"value":"8-1","text":"<pre>void selectionSort(int a[], int N) {<br>  for (int L = 0; L &lt;= N-2; ++L) { \/\/ O(<b>N<\/b>)<br>    int X = min_element(a+L, a+N) - a; \/\/ O(<b>N<\/b>)<br>    swap(a[X], a[L]); \/\/ O(1), X may be equal to L (no actual swap)<br>  }<br>}<\/pre><p>Total: O(<b>N<\/b><sup>2<\/sup>) \u2014 To be precise, it is similar to <a href=\"?slide=7-1\"><u>Bubble Sort analysis<\/u><\/a>.<\/p>","title":"Selection Sort, Kode C++ &amp; Analisa"},{"id":202,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:00:02","updated_at":"2022-01-04 14:13:18","section":176,"code":"$('#title-Selection').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.selectionSort, \"29,10,14,37,13\");","section_order":8,"value":"8-2","text":"<input class=\"mcq-answer\" id=\"mcq-answer-4\" value=\"26\" hidden><p>Quiz: <b>How many (real) swaps are required to sort [29, 10, 14, 37, 13] by Selection Sort?<\/b><\/p><form><input type=\"radio\" name=\"mcq-4-choice\" value=\"24\"> 1<br><input type=\"radio\" name=\"mcq-4-choice\" value=\"25\"> 2<br><input type=\"radio\" name=\"mcq-4-choice\" value=\"26\"> 3<br><input type=\"radio\" name=\"mcq-4-choice\" value=\"27\"> 4<br><\/form><button class=\"mcq-submit\" id=\"submit-4\">Submit<\/button> <span id=\"answer-status-4\"><\/span>","title":"Kuis"},{"id":178,"category":"sorting","order":9,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 18:14:12","updated_at":"2022-01-04 14:14:17","section":-1,"code":"$('#title-Insertion').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.insertionSort, \"40,13,20,8\");","section_order":-1,"value":"9","text":"<p><i>Insertion Sort<\/i> mirip dengan bagaimana kebanyakan orang menyusun kartu <i>poker<\/i> di tangan. <img src=\"https:\/\/puu.sh\/vfi6a\/e532309371.png\" alt=\"Tangan poker\"><\/p><ol><li>Mulai dengan satu kartu di tangan,<br><\/li><li>Pilih kartu berikutnya dan masukkan ke dalam posisi yang benar,<\/li><li>Ulang langkah tersebut untuk seluruh kartu.<\/li><\/ol><p>Tanpa basa-basi lagi, mari coba <span class=\"slide-actions\" onclick=\"doButtonAction10()\">Insertion Sort<\/span> pada larik contoh kecil <span style=\"white-space: normal;\">[40, 13, 20, 8]<\/span>.<\/p>","title":"Insertion Sort"},{"id":203,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:20:19","updated_at":"2021-12-26 14:26:02","section":178,"code":"$('#title-Insertion').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.insertionSort, \"40,13,20,8\");","section_order":9,"value":"9-1","text":"<pre>void insertionSort(int a[], int N) {<br>  for (int i = 1; i &lt; N; ++i) { \/\/ O(N)<br>    int X = a[i]; \/\/ X adalah elemen untuk dimasukkan<br>    int j = i-1;<br>    for (; j &gt;= 0 &amp;&amp; a[j] &gt; X; --j) \/\/ bisa cepat atau lambat<br>      a[j+1] = a[j]; \/\/ buat tempat untuk X<br>    a[j+1] = X; \/\/ indeks j+1 adalah titik pemasukkan<br>  }<br>}<\/pre>","title":"Insertion Sort, Kode C++ dan Analisa 1"},{"id":204,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:23:45","updated_at":"2021-12-26 14:26:06","section":178,"code":"$('#title-Insertion').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.insertionSort, \"40,13,20,8\");","section_order":9,"value":"9-2","text":"<p>Perulangan luar (<i>outer loop<\/i>) dijalankan <b>N<\/b>\u22121 kali, sepertinya ini cukup jelas.<\/p><p>Tetapi berapa kali perulangan dalam (<i>inner loop<\/i>) dilakukan tergantung pada masukan:<br><\/p><ol><li>Dalam kasus terbaik, larik sudah terurut menaik dan (a[j] &gt; X) selalu salah<br>Sehingga tidak ada pergeseran data yang terjadi dan perulangan dalam (<u><i>inner loop<\/i><\/u>) berjalan dalam O(<b>1<\/b>),<\/li><li>Dalam kasus terjelek, larik terurut terbalik (menurun) dan (a[j] &gt; X) selalu benar<br>Pemasukkan (<u><i>insertion<\/i><\/u>) selalu terjadi di depan larik dan perulangan dalam (<i>inner loop<\/i>) berjalan dalam O(<b>N<\/b>).<\/li><\/ol><p>Sehingga, waktu terbaik adalah O(<b>N \u00d7  1<\/b>) = O(<b>N<\/b>) dan waktu terburuk adalah O(<b>N \u00d7 N<\/b>) = O(<b>N<\/b><sup>2<\/sup>).<\/p>","title":"Insertion Sort: Analisa 2"},{"id":205,"category":"sorting","order":3,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-10 05:27:56","updated_at":"2022-01-04 14:15:45","section":178,"code":"$('#title-Insertion').click();\n$(\"#sort\").addClass(\"menu-highlighted\");\nchangeSortType(gw.insertionSort, \"40,13,20,8\");","section_order":9,"value":"9-3","text":"<input class=\"mcq-answer\" id=\"mcq-answer-5\" value=\"31\" hidden><p>Quiz: <b>What is the complexity of Insertion Sort on any input array?<\/b><\/p><form><input type=\"radio\" name=\"mcq-5-choice\" value=\"28\"> O(1)<br><input type=\"radio\" name=\"mcq-5-choice\" value=\"29\"> O(N)<br><input type=\"radio\" name=\"mcq-5-choice\" value=\"30\"> O(N log N)<br><input type=\"radio\" name=\"mcq-5-choice\" value=\"31\"> O(N^2)<br><\/form><button class=\"mcq-submit\" id=\"submit-5\">Submit<\/button> <span id=\"answer-status-5\"><\/span><br><br><p>Tanya instruktor anda bila anda tidak mengerti tentang hal ini atau baca catatan yang sejenis di <a href=\"?slide=10-10\"><u>slide ini<\/u><\/a>.<\/p>","title":"Kuis Mini"},{"id":555,"category":"sorting","order":10,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:08:40","updated_at":"2022-01-04 14:16:51","section":-1,"code":"","section_order":-1,"value":"10","text":"<p>Kita akan membahas dua (dan setengah) algoritma-algoritma berbasis-pembandingan segera:<\/p><ol><li><a href=\"?slide=10\"><u><i>Merge Sort<\/i><\/u><\/a>,<\/li><li><a href=\"?slide=11\"><u><i>Quick Sort<\/i><\/u><\/a> dan <a href=\"?slide=12\"><u>versi acaknya<\/u><\/a> (yang hanya memiliki satu perubahan).<\/li><\/ol><p>Algoritma-algoritma pengurutan ini biasanya diimplementasikan secara rekursif, menggunakan paradigma pemecahan masalah <i>Divide and Conquer<\/i>, dan berjalan dalam waktu O(<b>N<\/b> log <b>N<\/b>) untuk <i>Merge Sort<\/i> dan O(<b>N<\/b> log <b>N<\/b>) <i>secara ekspektasi<\/i> untuk <i>Quick Sort<\/i> Acak.<\/p><br><p>PS: Versi tidak-acak dari <i>Quick Sort<\/i> sayangnya berjalan dalam waktu O(<b>N<sup>2<\/sup><\/b>).<\/p>","title":"2.5 O(N log N) Pengurutan Pembandingan"},{"id":179,"category":"sorting","order":11,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 18:30:57","updated_at":"2020-10-06 04:41:09","section":-1,"code":"$('#title-Merge').click();","section_order":-1,"value":"11","text":"<p>Diberikan sebuah larik berisi <b>N<\/b> elemen, <i>Merge Sort<\/i> akan:<\/p><ol><li>Menggabungkan tiap pasang elemen (yang secara <i>default<\/i> terurut) menjadi larik-larik berukuran 2 elemen,<\/li><li>Menggabungkan tiap pasang larik-larik tersebut menjadi larik-larik berukuran 4 elemen, Ulangi proses ini...,<\/li><li>Langkah terakhir: Menggabungkan 2 larik-larik yang sudah terurut dengan jumlah <b>N<\/b>\/2 elemen (untuk memudahkan diskusi, kita berasumsi bahwa <b>N<\/b> genap) untuk mendapatkan larik yang terurut penuh dengan jumlah <b>N<\/b> elemen.<br><\/li><\/ol><p>Ini hanyalah ide general dan kita membutuhkan beberapa detail tambahan sebelum kita bisa membahas bentuk sebenarnya dari <i>Merge Sort<\/i>.<\/p>","title":"Merge Sort"},{"id":546,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 05:12:46","updated_at":"2022-01-04 14:17:39","section":179,"code":"$('#title-Merge').click();\nchangeSortType(gw.mergeSort, \"1,5,19,20,2,11,15,17\");","section_order":11,"value":"11-1","text":"<p>Kita akan membahas dengan detil algoritma <i>Merge Sort<\/i> ini dengan pertama-tama membahas sub-rutin terpentingnya: Proses penggabungan (<samp>merge<\/samp>) dalam O(<b>N<\/b>).<\/p><br><p>Diberikan dua larik yang sudah terurut, A dan B, dengan ukuran <b>N<sub>1<\/sub><\/b> dan <b>N<sub>2<\/sub><\/b>, kita dapat dengan efisien menggabungkan mereka mejadi satu larik terurut yang lebih besar dengan ukuran <b>N<\/b> = <b>N<sub>1<\/sub><\/b>+<b>N<sub>2<\/sub><\/b>, dalam waktu O(<b>N<\/b>).<\/p><br><p>Ini dapat diraih dengan cara membandingkan elemen terdepan dari kedua larik dan mengambil yang terkecil dari dua itu setiap waktu. Tetapi, sub-rutin <samp>merge<\/samp> yang sederhana tapi cepat O(<b>N<\/b>) ini akan membutuhkan larik tambahan untuk melakukan proses penggabungan ini dengan benar.<\/p>","title":"Sub-rutin Penting, O(N) Merge"},{"id":550,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:02:01","updated_at":"2022-02-02 14:33:40","section":179,"code":"$('#title-Merge').click();\nchangeSortType(gw.mergeSort, \"1,5,19,20,2,11,15,17\");","section_order":11,"value":"11-2","text":"<pre>void merge(int a[], int low, int mid, int high) {<br>  \/\/ subarray1 = a[low..mid], subarray2 = a[mid+1..high], terurut<br>  int N = high-low+1;<br>  int b[N]; \/\/ diskusi: kenapa kita butuh larik sementara b?<br>  int left = low, right = mid+1, bIdx = 0;<br>  while (left &lt;= mid &amp;&amp; right &lt;= high) \/\/ proses penggabungan<br>    b[bIdx++] = (a[left] &lt;= a[right]) ? a[left++] : a[right++];<br>  while (left &lt;= mid) b[bIdx++] = a[left++]; \/\/ sisanya, jika ada<br>  while (right &lt;= high) b[bIdx++] = a[right++]; \/\/ sisanya, jika ada<br>  for (int k = 0; k &lt; N; ++k) a[low+k] = b[k]; \/\/ kopi kembali<br>}<br><\/pre><p>Cobalah <span class=\"slide-actions\" onclick=\"doButtonAction12()\">Merge Sort<\/span> pada larik contoh <span style=\"white-space: normal;\">[1, 5, 19, 20, 2, 11, 15, 17]&nbsp;<\/span>yang sebagian pertamanya telah terurut [1, 5, 19, 20] dan sebagian keduanya juga telah terurut [2, 11, 15, 17]. Fokus kepada penggabungan terakhir dari algoritma <i>Merge Sort<\/i>.<\/p>","title":"Implementasi C++ dari Sub-rutin Merge"},{"id":547,"category":"sorting","order":3,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 06:16:03","updated_at":"2017-06-06 03:45:26","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-3","text":"<p>Sebelum kita lanjutkan, mari berbicara tentang <i>Divide and Conquer <\/i>(disingkat sebagai D&amp;C), sebuah paradigma pemecahan masalah yang kuat.<\/p><br><p>Algoritma <i>Divide and Conquer<\/i> menyelesaikan (sejenis) masalah \u2014 seperti masalah pengurutan kita \u2014 dalam beberapa langkah-langkah berikut:<\/p><ol><li>Langkah <i>Divide<\/i>: Membagi masalah yang asli dan besar menjadi masalah-masalah yang lebih kecil dan secara rekursif menyelesaikan masalah-masalah yang lebih kecil tersebut,<\/li><li>Langkah <i>Conquer<\/i>: Gabungkan hasil-hasil dari masalah-masalah yang lebih kecil tersebut untuk menghasilkan hasil dari masalah yang asli dan besar.<\/li><\/ol>","title":"Paradigma Divide and Conquer"},{"id":549,"category":"sorting","order":4,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:01:32","updated_at":"2021-12-26 14:31:25","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-4","text":"<p><i>Merge Sort<\/i> adalah algoritma pengurutan bersifat <i>Divide and Conquer<\/i>.<\/p><br><p>Langkah pembagian (<i>divide<\/i>) mudah saja: Bagi larik yang sekarang menjadi dua bagian (sama besar jika <b>N<\/b> genap atau satu sisi satu elemen sedikit lebih besar jika <b>N<\/b> ganjil) dan lalu secara rekursif mengurutkan kedua bagian tersebut.<\/p><br><p>Langkah penaklukkan (<i>conquer<\/i>) adalah langkah yang melakukan usaha terbesar: Gabungkan dua bagian (yang sudah terurut) untuk membentuk larik yang terurut, menggunakan sub-rutin penggabungan (<i>merge<\/i>) <a href=\"?slide=10-2\"><u>yang dibahas sebelumnya<\/u><\/a>.<\/p>","title":"Merge Sort Sebagai Algoritma D&amp;C"},{"id":567,"category":"sorting","order":5,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 08:28:03","updated_at":"2017-06-06 03:45:29","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-5","text":"<pre>void mergeSort(int a[], int low, int high) {<br>  \/\/ larik yang akan diurutkan adalah a[low..high]<br>  if (low &lt; high) { \/\/ kasus dasar: low &gt;= high (0 or 1 item)<br>    int mid = (low+high) \/ 2;\t<br>    mergeSort(a, low  , mid ); \/\/ bagi jadi dua bagian<br>    mergeSort(a, mid+1, high); \/\/ lalu urutkan secara rekursif<br>    merge(a, low, mid, high); \/\/ kuasai: sub-rutin merge<br>  }<br>}<\/pre>","title":"Implementasi C++ dari Merge Sort"},{"id":548,"category":"sorting","order":6,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:01:19","updated_at":"2022-01-04 14:19:38","section":179,"code":"$('#title-Merge').click();\nchangeSortType(gw.mergeSort, \"7,2,6,3,8,4,5\");","section_order":11,"value":"11-6","text":"<p>Dibandingkan dengan apa yang biasanya ditampilkan di banyak buku-buku teks Ilmu Komputer yang dicetak (karena buku-buku sifatnya statis), eksekusi sebenarnya dari <i>Merge Sort<\/i> <b>tidak<\/b> membagi kedua sub-larik <b>level demi level<\/b>, tetapi <i>Merge Sort<\/i> akan secara rekursif mengurutkan sub-larik <b>kiri<\/b> terlebih dahulu sebelum mengurutkan sub-larik <b>kanan<\/b>.<br><\/p><br><p>Lebih detailnya, menjalankan <span class=\"slide-actions\" onclick=\"doButtonAction12()\">Merge Sort<\/span> pada larik contoh [7, 2, 6, 3, 8, 4, 5], <i>Merge Sort<\/i> akan merekursi ke [7, 2, 6, 3], lalu [7, 2], lalu [7] (sebuah elemen tunggal, yang sudah terurut secara <i>default<\/i>), kembali, rekursi ke [2] (terurut), kembali, lalu menggabungkan [7, 2] menjadi [2, 7], sebelum <i>Merge Sort<\/i> memproses [6, 3] dan selanjutnya.<\/p>","title":"Demonstrasi"},{"id":551,"category":"sorting","order":7,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:03:34","updated_at":"2017-06-06 03:46:01","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-7","text":"<p>Dalam <i>Merge Sort<\/i>, usaha terbanyak dilakukan dalam langkah <i>conquer<\/i>\/<i>merge <\/i>karena langkah <i>divide<\/i> sebenarnya tidak melakukan apa-apa (dianggap O(<b>1<\/b>)).<\/p><br><p>Ketika kita memanggil <samp>merge(a, low, mid, high)<\/samp>, kita memproses <b>k = (high-low+1)<\/b> elemen.<br>Akan ada paling banyak <b>k-1<\/b> pembandingan.<br>Ada <b>k<\/b> perpindahan dari larik asli <b>a<\/b> ke larik temporer <b>b<\/b> dan <b>k<\/b> perpindahan lainnya untuk menyalin balik.<br>Secara total, jumlah operasi dalam operasi sub-rutin <samp>merge<\/samp> adalah &lt; 3<b>k<\/b>-1 = O(<b>k<\/b>).<\/p><br><p>Pertanyaan penting berikutnya adalah berapa kali sub-rutin <samp>merge<\/samp> ini dipanggil?<\/p>","title":"Merge Sort: Analisa Bagian 1"},{"id":552,"category":"sorting","order":8,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:03:58","updated_at":"2017-06-06 03:46:02","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-8","text":"<img src=\"https:\/\/visualgo.net\/img\/merge.png\" width=\"500\" alt=\"The Recursion Tree of Merge Sort\">","title":"Merge Sort: Analisa Bagian 2"},{"id":553,"category":"sorting","order":9,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:04:24","updated_at":"2022-01-04 14:20:44","section":179,"code":"$('#title-Merge').click();","section_order":11,"value":"11-9","text":"<p>Level 1: 2^0=1 panggilan kepada merge() dengan <b>N<\/b>\/2^1 elemen masing-masing, O(2^0 x 2 x <b>N<\/b>\/2^1) = O(<b>N<\/b>)<br>Level 2: 2^1=2 panggilan kepada merge() dengan <b>N<\/b>\/2^2 elemen masing-masing, O(2^1 x 2 x <b>N<\/b>\/2^2) = O(<b>N<\/b>)<br>Level 3: 2^2=4 panggilan kepada merge() dengan <b>N<\/b>\/2^3 elemen masing-masing, O(2^2 x 2 x <b>N<\/b>\/2^3) = O(<b>N<\/b>)<br>...<br>Level (log <b>N<\/b>): 2^(log <b>N<\/b>-1) (atau <b>N<\/b>\/2) panggilan kepada merge() dengan <b>N<\/b>\/2^log <b>N<\/b> (or 1) elemen masing-masing, O(<b>N<\/b>)<\/p><br><p>Ada log <b>N<\/b> level dan di setiap level, kita melakukan usaha sebesar O(<b>N<\/b>), sehingga kompleksitas waktu seluruhnya adalah O(<b>N<\/b> log <b>N<\/b>). <a href=\"?slide=13-1\"><u>Nanti<\/u><\/a>, kita akan melihat bahwa ini adalah algoritma pengurutan (berbasis-pembandingan) yang sudah optimal, atau dengan kata lain, kita tidak bisa membuat algoritma lebih baik dari <i>Merge Sort<\/i> ini.<\/p>","title":"Merge Sort: Analisa Bagian 3"},{"id":566,"category":"sorting","order":10,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:20:32","updated_at":"2022-01-04 14:21:49","section":179,"code":"","section_order":11,"value":"11-10","text":"<p>Bagian bagus dari <i>Merge Sort<\/i> yang paling penting adalah garansi performa O(<b>N<\/b> log <b>N<\/b>), tidak tergantung pada urutan asli dari masukan. Dengan kata lain, <b>tidak ada<\/b> kasus tes yang bisa membuat <i>Merge Sort<\/i> berjalan lebih lambat dari O(<b>N<\/b> log <b>N<\/b>) untuk <b>segala <\/b>larik dengan <b>N<\/b> elemen.<\/p><br><p><i>Merge Sort<\/i> sangat cocok untuk mengurutkan masukan yang sangat besar karena O(<b>N<\/b> log <b>N<\/b>) bertumbuh jauh lebih lambat dari algoritma-algoritma pengurutan yang membutuhkan waktu O(<b>N<\/b><sup>2<\/sup>) seperti yang <a href=\"?slide=5\"><u>dibahas sebelumnya<\/u><\/a>.<\/p><br><p>Tetapi ada juga beberapa bagian yang tidak bagus dari <i>Merge Sort<\/i>. Pertama, sebenarnya tidak mudah untuk mengimplementasikan <i>Merge Sort<\/i> dari awal (<a href=\"?slide=18-2\"><u>tetapi sebenarnya kita tidak perlu melakukannya<\/u><\/a>). Kedua, <i>Merge Sort<\/i> membutuhkan tempat tambahan sebesar O(<b>N<\/b>) dalam <a href=\"?slide=10-2\"><u>proses penggabungan<\/u><\/a>, sehingga tidak efisien secara memori dan <a href=\"?slide=16-1\"><u>tidak di-tempat<\/u><\/a>. <span style=\"white-space: normal;\">Ngomong-ngomong, bila anda tertarik untuk melihat apa yang sudah dilakukan untuk mengatasi bagian yang tidak bagus dari <i>Merge Sort<\/i> (klasik) ini, anda bisa membaca <\/span><a href=\"https:\/\/en.wikipedia.org\/wiki\/Merge_sort#Variants\" target=\"_blank\"><u>ini<\/u><\/a><\/p><p><br><\/p><p><i>Merge Sort<\/i> juga adalah algoritma <a href=\"?slide=16-2\"><u>pengurutan yang stabil<\/u><\/a>. Diskusi: Kenapa?<\/p>","title":"Bagus dan Jeleknya"},{"id":775,"category":"sorting","order":11,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-01-04 14:22:28","updated_at":"2022-01-04 14:26:06","section":179,"code":"","section_order":11,"value":"11-11","text":"<pre>b[bIdx++] = (a[left] &lt;= a[right]) ? a[left++] : a[right++];<br><\/pre><p>Lihat diatas. Jika a = yang depan dari sub-larik kiri sama dengan b = yang depan dari sub-larik kanan, maka rutin <i>Merge<\/i> akan mengambil a terlebih dahulu, sehingga menjaga stabilitas. Catat bahwa satu perubahan karakter dibawah (sadari &lt; versus &lt;=) membuat <i>Merge Sort<\/i> tidak lagi stabil.<\/p><pre>b[bIdx++] = (a[left] &lt; a[right]) ? a[left++] : a[right++];<br><\/pre>","title":"Jawabannya"},{"id":180,"category":"sorting","order":12,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 19:23:20","updated_at":"2021-12-26 14:33:36","section":-1,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":-1,"value":"12","text":"<p><i>Quick Sort<\/i> adalah algoritma pengurutan lain yang juga berbasis <i>Divide and Conquer<\/i> (satu lagi yang telah dibahas di Kuliah Maya ini adalah <a href=\"?slide=10\"><u><i>Merge Sort<\/i><\/u><\/a>).<\/p><br><p>Kita akan melihat bahwa versi deterministik, tidak acak dari <i>Quick Sort<\/i> bisa memiliki kompleksitas waktu yang jelek, yaitu O(<b>N<\/b><sup>2<\/sup>) pada masukan jahat (<i>adversary<\/i>) sebelum kita melanjutkan pembahasan dengan versi <a href=\"?slide=12\"><u>acak<\/u><\/a> yang lebih bisa dipakai nantinya.<\/p>","title":"Quick Sort"},{"id":556,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:16:06","updated_at":"2022-01-04 14:39:20","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-1","text":"<p>Langkah <i>Divide<\/i>: Pilih elemen <b>p<\/b> (dinamai sebagai <i>pivot<\/i>)<br>Lalu partisi (<i>partition<\/i>) elemen-elemen <b>a[i..j]<\/b> menjadi tiga bagian: <b>a[i..m-1]<\/b>, <b>a[m]<\/b>, dan <b>a[m+1..j]<\/b>.<br><b>a[i..m-1]<\/b> (kemungkinan kosong) berisi elemen-elemen yang lebih kecil dari <b>p<\/b>.<br><b>a[m]<\/b> adalah <i>pivot<\/i> <b>p<\/b>, indeks <b>m<\/b> adalah posisi <b>p<\/b> yang benar didalam larik terurut <b>a <\/b>nantinya.<br><b>a[m+1..j]<\/b> (kemungkinan kosong) berisi elemen-elemen yang lebih besar <i>atau sama dengan<\/i> <b>p<\/b>.<br>Lalu, urutkan kedua bagian ini secara rekursif.<\/p><br><p>Langkah <i>Conquer<\/i>: Jangan kaget... Kita tidak melakukan apa-apa :O!<\/p><br><p>Jika anda membandingkan ini dengan <a href=\"?slide=10-4\"><u><i>Merge Sort<\/i><\/u><\/a>, anda akan melihat bahwa langkah-langkah D&amp;C dari <i>Quick Sort<\/i> terbalik total dengan <i>Merge Sort<\/i>.<\/p>","title":"Quick Sort sebagai Algoritma D&amp;C"},{"id":574,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:19:13","updated_at":"2022-01-04 14:41:37","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-2","text":"<p>Kita akan membahas dengan detil algoritma <i>Quick Sort<\/i> ini dengan pertama-tama membahas sub-rutin terpentingnya: O(<b>N<\/b>) partition.<\/p><br><p>Untuk mempartisi <b>a[i..j]<\/b>, kita pertama-tama memilih <b>a[i]<\/b> sebagai <i>pivot<\/i> <b>p<\/b>.<br><\/p><p>Elemen-elemen sisanya (yaitu <b>a[i+1..j]<\/b>) terbagi jadi 3 wilayah:<\/p><ol><li><b>S1<\/b> = <b>a[i+1..m]<\/b> dimana elemen-elemennya &lt; <b>p<\/b>,<\/li><li><b>S2<\/b> = <b>a[m+1..k-1]<\/b> dimana elemen-elemennya \u2265 <b>p<\/b>, dan<\/li><li>Tidak diketahui = <b>a[k..j]<\/b>, dimana elemen-elemennya belum dimasukkan ke <b>S1<\/b> atau <b>S2<\/b>.<\/li><\/ol><p>Diskusi: Kenapa kita memilih <b>p<\/b> = <b>a[i]<\/b>? Apakah ada pilihan-pilihan yang lain?<\/p><p><br><\/p><p>Diskusi yang lebih susah: Apakah baik untuk selalu menaruh item(-item) yang == <b>p<\/b> selalu ke S2?<\/p>","title":"Sub-rutin Penting, O(N) Partition"},{"id":583,"category":"sorting","order":3,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-06 03:49:51","updated_at":"2022-01-04 14:42:47","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-3","text":"<p>Pilihan <b>p<\/b> = <b>a[i]<\/b> sembarang saja. Elemen apapun diantara <b>a[i..j]<\/b> bisa dipilih menjadi <i>pivot<\/i>.<\/p><br><p>Tetapi kita akan <a href=\"?slide=11-12\"><u>nanti melihat<\/u><\/a> bahwa menentukan pivot dengan cara deterministik bisa menyebabkan kompleksitas waktu yang jelek yaitu O(<b>N<\/b><sup>2<\/sup>) sehingga kita nanti akan <a href=\"?slide=12\"><u>mengacaknya<\/u><\/a>.<\/p><p><br><\/p><p>Mengenai item(-item) yang duplikat, sebenarnya <b>tidak<\/b> baik untuk selalu menaruh item(-item) yang == <b>p<\/b> selalu ke region S1 (atau S2) karena hal itu akan menyebabkan bahkan <i>Quick Sort<\/i> versi Acak berjalan dalam O(<b>N<sup>2<\/sup><\/b>). Implementasi yang lebih baik adalah untuk secara acak menaruh item(-item) yang == <b>p<\/b> ke S1 atau S2, menggunakan probabilitas 50-50 (ada cara lain untuk melakukan hal ini).<\/p>","title":"Jawabannya"},{"id":575,"category":"sorting","order":4,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:24:25","updated_at":"2022-01-04 14:45:03","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-4","text":"<p>Pada awalnya, region <b>S1<\/b> dan <b>S2<\/b> dua-duanya kosong, yaitu semua elemen kecuali <i>pivot<\/i> <b>p<\/b> yang terpilih berada dalam region yang tidak diketahui.<\/p><br><p>Lalu, untuk setiap elemen <b>a[k]<\/b> di region yang tidak diketahui, kita membandingkan <b>a[k]<\/b> dengan <b>p<\/b> dan memutuskan satu dari tiga kasus berikut:<\/p><ol><li>Jika <b>a[k]<\/b> &gt; <b>p<\/b>, taruh <b>a[k]<\/b> di <b>S2<\/b>,<\/li><li>Jika <b>a[k] &lt; p<\/b>, taruh <b>a[k]<\/b> di <b>S1<\/b>,<\/li><li>Jika <b>a[k] == p<\/b>, lempar sebuah koin dan taruh <b>a[k]<\/b> ke <b>S1<\/b>\/<b>S2<\/b> jika jatuh kepala\/ekor, masing-masing.<\/li><\/ol><p>Ketiga kasus-kasus ini akan dijelaskan lebih detil di dua slide berikutnya.<\/p><br><p>Pada akhirnya, kita menukar <b>a[i]<\/b> dan <b>a[m]<\/b> untuk menaruh pivot <b>p<\/b> tepat diantara <b>S1<\/b> dan <b>S2<\/b>.<\/p>","title":"Partition - Lanjutan"},{"id":576,"category":"sorting","order":5,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:25:02","updated_at":"2022-01-04 14:45:32","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-5","text":"<img src=\"https:\/\/visualgo.net\/img\/partition1.png\" width=\"500\" alt=\"Case when a[k] \u2265 p, increment k, extend S2 by 1 item\">","title":"Partisi - Kasus ketika a[k] &gt; p"},{"id":577,"category":"sorting","order":6,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:26:05","updated_at":"2017-06-06 03:49:59","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-6","text":"<img src=\"https:\/\/visualgo.net\/img\/partition2.png\" width=\"500\" alt=\"Case when a[k] < p, increment m, swap a[k] with a[m], increment k, extend S1 by 1 item\">","title":"Partition - Kasus ketika a[k] &lt; p"},{"id":579,"category":"sorting","order":7,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:44:26","updated_at":"2022-01-04 14:50:21","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-7","text":"<pre>int partition(int a[], int i, int j) {<br>  int p = a[i]; \/\/ p sebagai pivot<br>  int m = i; \/\/ S1 dan S2 pada mulanya kosong<br>  for (int k = i+1; k &lt;= j; ++k) { \/\/ jelajah bagian baru<br>    if ((a[k] &lt; p) || ((a[k] == p) &amp;&amp; (rand()%2 == 0))){ \/\/ case 2+3<br>      ++m;<br>      swap(a[k], a[m]); \/\/ algoritma C++ STL std::swap<br>    } \/\/ kita tidak melakukan apa-apa pada kasus 1: a[k] &gt; p<br>  }<br>  swap(a[i], a[m]); \/\/ langkah terakhir, tukar pivot dengan a[m]<br>  return m; \/\/ kembalikan indeks pivot<br>}<\/pre>","title":"Implementasi C++ dari Partition"},{"id":578,"category":"sorting","order":8,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:43:05","updated_at":"2017-06-06 03:49:57","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,27,16\");","section_order":12,"value":"12-8","text":"<pre>void quickSort(int a[], int low, int high) {<br>  if (low &lt; high) {<br>    int m = partition(a, low, high); \/\/ O(N)<br>    \/\/ a[low..high] ~&gt; a[low..m\u20131], pivot, a[m+1..high]<br>    quickSort(a, low, m-1); \/\/ urutkan sub-larik kiri<br>    \/\/ a[m] = pivot telah terurut setelah partition<br>    quickSort(a, m+1, high); \/\/ lalu urutkan sub-larik kanan<br>  }<br>}<\/pre>","title":"Implementasi C++ dari Quick Sort"},{"id":557,"category":"sorting","order":9,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:16:20","updated_at":"2022-01-04 15:16:55","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"27,38,12,39,29,16\");","section_order":12,"value":"12-9","text":"<p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction13()\">Quick Sort<\/span> pada larik contoh [27, 38, 12, 39, 29, 16]. Kita akan bahas langkah pertama dari partition sebagai berikut:<br>Kita set <b>p = a[0] = 27<\/b>.<br>Kita set <b>a[1] = 38<\/b> sebagai bagian <b>S2<\/b> jadi <b>S1 = {}<\/b> dan <b>S2 = {38}<\/b>.<br>Kita tukar <b>a[1] = 38<\/b> dengan <b>a[2] = 12<\/b> jadi <b>S1 = {12}<\/b> dan <b>S2 = {38}<\/b>.<br>Kita set <b>a[3] = 39<\/b> dan juga <b>a[4] = 29<\/b> berikutnya sebagai bagian <b>S2<\/b> jadi <b>S1 = {12}<\/b> dan <b>S2 = {38,39,29}<\/b>.<br>Kita tukar <b>a[2] = 38<\/b> dengan <b>a[5] = 16<\/b> jadi <b>S1 = {12,16}<\/b> dan <b>S2 = {39,29,38}<\/b>.<br>Kita tukar <b>p = a[0] = 27<\/b> dengan <b>a[2] = 16<\/b> jadi <b>S1 = {16,12}<\/b>, <b>p = {27}<\/b>, dan <b>S2 = {39,29,38}<\/b>.<\/p><br><p>Setelah ini, <b>a[2] = 27<\/b> dijamin terurut sekarang dan <i>Quick Sort<\/i> akan mengurutkan secara rekursif sisi kiri <b>a[0..1]<\/b> duluan dan nanti mengurutkan secara rekursif sisi kanan <b>a[3..5]<\/b>.<\/p>","title":"Demonstrasi"},{"id":558,"category":"sorting","order":10,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:16:37","updated_at":"2021-12-26 14:35:10","section":180,"code":"$('#title-Quick').click();","section_order":12,"value":"12-10","text":"<p>Pertama-tama, kita analisa biaya satu pemanggilan <samp>partition<\/samp>.<\/p><br><p>Didalam <samp>partition(a, i, j)<\/samp>, hanya ada satu <i>for-loop<\/i> yang diulang (j-i) kali. Karena j bisa sebesar <b>N<\/b>-1 dan i bisa sekecil 0, maka kompleksitas waktu dari partition adalah O(<b>N<\/b>).<\/p><br><p>Mirip dengan <a href=\"?slide=10-7\"><u>analisa <i>Merge Sort<\/i><\/u><\/a>, kompleksitas waktu dari <i>Quick Sort<\/i> tergantung seberapa banyak <samp>partition(a, i, j)<\/samp> dipanggil.<\/p>","title":"Quick Sort: Analisa Bagian 1"},{"id":559,"category":"sorting","order":11,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:16:53","updated_at":"2022-01-04 15:19:00","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"5,18,23,39,44,50\");","section_order":12,"value":"12-11","text":"<p>Ketika larik <b>a<\/b> sudah dalam urutan menaik, misalkan <b>a<\/b> = [5, 18, 23, 39, 44, 50}, <span class=\"slide-actions\" onclick=\"doButtonAction13()\">Quick Sort<\/span><i> <\/i>akan mengatur <b>p = a[0] = 5<\/b>, dan akan mengembalikan <b>m = 0<\/b>, oleh karena itu membuat region <b>S1<\/b> <b>kosong<\/b> dan region <b>S2<\/b>: Semuanya kecuali pivot (<b>N<\/b>-1 elemen).<\/p>","title":"Quick Sort: Analisa Bagian 2"},{"id":580,"category":"sorting","order":12,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-05 03:35:23","updated_at":"2021-12-26 14:35:41","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"5,18,23,39,44,50\");","section_order":12,"value":"12-12","text":"<p>Pada skenario terjelek tersebut, inilah yang terjadi:<\/p><br><img src=\"https:\/\/visualgo.net\/img\/qsort_worstcase.png\" width=\"250\" alt=\"Worst Case analysis of Quick Sort\"><br><p>Partisi pertama membutuhkan waktu O(<b>N<\/b>), membagi <b>a<\/b> menjadi 0, 1, <b>N<\/b>-1 elemen-elemen, lalu rekursi ke-kanan.<br>Yang kedua membutuhkan waktu O(<b>N<\/b>-1), membagi <b>a<\/b> menjadi 0, 1, <b>N<\/b>-2 elemen-elemen, lalu rekursi ke-kanan lagi.<br>...<br>Sampai yang terakhir, uartisi ke <b>N<\/b> membagi <b>a<\/b> menjadi 0, 1, 1 elemen, dan rekursi <i>Quick Sort<\/i> berhenti.<br><\/p><br><p>Ini adalah pola klasik <b>N+(N-1)+(N-2)+...+1<\/b>, yang disederhanakan sebagai O(<b>N<\/b><sup>2<\/sup><span style=\"white-space: normal;\">), analisa yang mirip dengan yang&nbsp;<\/span><a href=\"https:\/\/visualgo.net\/translation\/id\/sorting\/none\/all\/1?slide=6-1\" style=\"white-space: normal;\"><u>di slide analisa Bubble Sort ini<\/u><\/a><span style=\"white-space: normal;\">...<\/span><\/p>","title":"Quick Sort: Analisa Bagian 3"},{"id":582,"category":"sorting","order":13,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-05 03:51:20","updated_at":"2021-12-26 14:35:58","section":180,"code":"$('#title-Quick').click();\nchangeSortType(gw.quickSort, \"4,1,3,2,6,5,7\");","section_order":12,"value":"12-13","text":"<p>Skenario terbaik dari <i>Quick Sort<\/i> terjadi ketika partition selalu membagi larik menjadi <b>dua bagian yang sama besar<\/b>, seperti <a href=\"?slide=10-8\"><u><i>Merge Sort<\/i><\/u><\/a>.<\/p><br><p>Ketika itu terjadi, kedalaman rekursi hanyalah O(log <b>N<\/b>).<\/p><br><p>Karena setiap level membutuhkan O(<b>N<\/b>) pembandingan, kompleksitas waktu adalah O(<b>N<\/b> log <b>N<\/b>).<\/p><br><p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction13()\">Quick Sort<\/span> di contoh larik masukan yang telah dipersiapkan secara khusus <span style=\"white-space: normal;\">[4, 1, 3, 2, 6, 5, 7]<\/span>.<\/p><p>Pada prakteknya, hal ini jarang terjadi, sehingga kita harus memikirkan cara yang lebih baik: <a href=\"?slide=12\"><u><i>Quick Sort<\/i> Acak<\/u><\/a>.<\/p>","title":"Quick Sort: Kasus Terbaik (Jarang)"},{"id":181,"category":"sorting","order":13,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 19:37:45","updated_at":"2022-01-04 15:25:34","section":-1,"code":"$('#title-RandomizedQuick').click();\nchangeSortType(gw.randomizedQuickSort, DEFAULT_DATA);","section_order":-1,"value":"13","text":"<p>Sama seperti <b><i>Quick Sort<\/i><\/b> tetapi sebelum menjalankan algoritma partisi, algoritma ini <b>secara acak <\/b>memilih sebuah pivot diantara <b>a[i..j]<\/b> dibandingkan dengan selalu memilih <b>a[i]<\/b> (atau indeks tetap lainnya diantara <b>[i..j]<\/b>) secara deterministik.<\/p><p><br><\/p><p>Latihan kecil: Implementasikan ide diatas pada implementasi yang ditunjukkan di <a href=\"https:\/\/visualgo.net\/translation\/id\/sorting\/noshown\/all\/1?slide=11-7\"><u>slide ini<\/u><\/a>!<br><\/p><br><p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction14()\">Random Quick Sort<\/span> pada larik yang besar dan agak acak <b>a<\/b><span style=\"white-space: normal;\">&nbsp;<\/span><span style=\"white-space: normal;\">= [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48] terasa cepat<\/span>.<\/p>","title":"Quick Sort Acak"},{"id":569,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:07:14","updated_at":"2022-01-04 15:28:42","section":181,"code":"","section_order":13,"value":"13-1","text":"<p>Akan dibutuhkan kuliah sekitar 1 jam untuk menjelaskan dengan baik kenapa versi acak dari <i>Quick Sort<\/i> mempunyai kompleksitas waktu yang diharapkan O(<b>N<\/b> log <b>N<\/b>) pada larik masukan <b>apapun<\/b> dengan <b>N<\/b> elemen.<\/p><br><p>Dalam Kuliah Maya ini, kita akan berasumsi bahwa ini benar.<\/p><br><p>Jika anda membutuhkan penjelasan non formal: Bayangkan bahwa versi acak dari <i>Quick Sort<\/i> yang mengacak pemilihan <i>pivot<\/i>, kita <b>tidak<\/b> akan selalu mendapat pembagian yang sangat jelek yaitu 0 (kosong), 1 (<i>pivot<\/i>), dan <b>N<\/b>-1 elemen lainnya. Kombinasi dari beruntung (setengah-pivot-setengah), kira-kira beruntung, kira-kira tidak beruntung, dan sangat tidak beruntung (kosong, <i>pivot<\/i>, sisanya) menghasilkan kompleksitas waktu rata-rata O(<b>N<\/b> log <b>N<\/b>).<\/p><p><br><\/p><p><span style=\"white-space: normal;\">Diskusi: Untuk implementasi dari&nbsp;<\/span><a href=\"https:\/\/visualgo.net\/translation\/id\/sorting\/noshown\/all\/1?slide=12-4\" style=\"white-space: normal;\"><u>Partisi<\/u><\/a><span style=\"white-space: normal;\">, apa yang terjadi jika <b>a[k] == p<\/b>, kita <i>selalu<\/i> menaruk <b>a[k]<\/b> pada salah satu sisi (<b>S1<\/b> atau <b>S2<\/b>) secara deterministik?<\/span><\/p>","title":"Analisa \"Magis\""},{"id":776,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-01-04 15:28:57","updated_at":"2022-01-04 15:29:59","section":181,"code":"","section_order":13,"value":"13-2","text":"Jika hal itu terjadi, maka Quick Sort Acak menjadi O(<b>N<\/b><sup>2<\/sup>) lagi.","title":"Jawabannya"},{"id":560,"category":"sorting","order":14,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:17:28","updated_at":"2021-12-26 14:37:16","section":-1,"code":"$('#title-Counting').click();","section_order":-1,"value":"14","text":"<p>Kita akan membahas dua algoritma-algoritma pengurutan yang <b>tidak berbasis-pembandingan<\/b> di beberapa slide berikut ini:<\/p><ol><li><a href=\"?slide=14\"><u><i>Counting Sort<\/i><\/u><\/a>,<\/li><li><a href=\"?slide=15\"><u><i>Radix Sort<\/i><\/u><\/a>.<\/li><\/ol><p>Algoritma-algoritma pengurutan ini bisa lebih cepat dari batas bawah algoritma pengurutan berbasis-pembandingan yaitu \u03a9(<b>N<\/b> log <b>N<\/b>) karena mereka <b>tidak<\/b> membandingkan elemen-elemen dari larik.<\/p>","title":"2 O(N) Algoritma Tidak Membandingkan"},{"id":561,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:17:53","updated_at":"2022-01-04 15:30:31","section":560,"code":"$('#title-Counting').click();","section_order":14,"value":"14-1","text":"<p>Sudah diketahui (tapi tidak dibuktikan di Kuliah Maya ini karena akan membutuhkan 1 jam kuliah lagi) bahwa semua algortima pengurutan <b>berbasis-pembandingan<\/b> mempunyai kompleksitas waktu<b> <\/b>batas bawah sebesar \u03a9(<b>N<\/b> log <b>N<\/b>).<\/p><br><p>Jadi, algoritma pengurutan berbasis-pembandingan apapun dengan kompleksitas terjelek O(<b>N<\/b> log <b>N<\/b>), seperti <a href=\"?slide=10-9\"><u><i>Merge Sort<\/i><\/u><\/a> sebenarnya algoritma yang sudah optimal, kita tidak bisa berbuat lebih baik dari itu.<\/p><br><p>Tetapi, kita dapat mendapatkan algoritma pengurutan yang lebih cepat \u2014 yaitu dalam O(<b>N<\/b>) \u2014 jika ada beberapa asumsi-asumsi dari larik masukan sehingga kita dapat menghindari pembandingan dari elemen-elemen untuk menentukan urutan.<\/p>","title":"Batas Bawah dari Algoritma Pengurutan"},{"id":182,"category":"sorting","order":15,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 19:43:21","updated_at":"2020-10-06 04:41:06","section":-1,"code":"$('#title-Counting').click();","section_order":-1,"value":"15","text":"<p><b>Asumsi<\/b>: Jika elemen-elemen yang akan diurutkan adalah <b>bilangan-bilangan bulat dengan <i>range<\/i> kecil<\/b>, kita dapat menghitung frekuensi dari setiap bialngan bulat (dalam <i>range<\/i> kecil tersebut) dan lalu mengecek range kecil tersebut untuk mengeluarkan elemen-elemen tersebut dalam urutan terurut.<\/p><br><p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction15()\">Counting Sort<\/span> pada larik contoh diatas dimana semua bilangan-bilangan bulat berada dalam [1..9], sehingga kita hanya perlu menghitung berapa kali bilangan 1 muncul, bilangan 2 muncul, ..., bilangan 9 muncul, dan lalu mengecek 1 sampai 9 untuk mencetak <b>x<\/b> kopi dari bilangan <b>y<\/b> jika frekuensi[<b>y<\/b>] = <b>x<\/b>.<\/p><br><p>Kompleksitas waktunya adalah O(<b>N<\/b>) untuk menghitung frekuensi-frekuensi dan O(<b>N+k<\/b>) untuk mencetak keluaran dalam urutan terurut dimana <b>k<\/b> adalah <i>range<\/i> dari bilangan-bilangan bulat masukan, yang adalah 9-1+1 = 9 dalam contoh ini. Kompleksitas waktu dari <i>Counting Sort<\/i> menjadi O(<b>N+k<\/b>), yang adalah O(<b>N<\/b>) jika <b>k<\/b> kecil.<\/p><br><p>Kita tidak bisa melakukan bagian perhitungan dari <i>Counting Sort<\/i> ketika <b>k<\/b> cukup besar karena keterbatasan memori, karena kita harus menyimpan frekuensi-frekuensi dari <b>k<\/b> bilangan-bilangan bulat tersebut.<\/p>","title":"Counting Sort"},{"id":183,"category":"sorting","order":16,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 20:11:59","updated_at":"2021-12-26 14:38:39","section":-1,"code":"$('#title-Radix').click();","section_order":-1,"value":"16","text":"<p><b>Asumsi<\/b>: Jika elemen-elemen yang akan diurutkan adalah <b>bilangan-bilangan bulat dengan <i>range<\/i> besar tetapi sedikit jumlah digit<\/b>, kita dapat menggabungkan ide <a href=\"?slide=14\"><u><i>Counting Sort<\/i><\/u><\/a> dengan <i>Radix Sort<\/i> untuk mencapai kompleksitas waktu linear.<\/p><br><p>Dalam <i>Radix Sort<\/i>, kita memperlakukan setiap elemen yang akan diurutkan sebagai <i>string<\/i> dengan <b>w<\/b> digit (kita tambahkan bilangan-bilangan bulat yang mempunyai kurang dari <b>w<\/b> digit dengan angka nol pembuka jika diperlukan).<\/p><br><p>Dari digit yang paling tidak signifikan (yang paling kanan) ke digit yang paling signifikan (yang paling kiri), kita melakukan satu pass ke semua <b>N<\/b> elemen-elemen dan menaruh mereka sesuai dengan digit aktif ke 10 Antrean (<i>Queues<\/i>) (satu untuk setiap digit [0..9]), yang seperti <i>Counting Sort<\/i> <i>termodifikasi<\/i> karena yang ini menjaga <a href=\"?slide=16-2\"><u>stabilitas<\/u><\/a>. Lalu kita menggabungkan kembali group-group tersebut untuk iterasi selanjutnya.<\/p><br><p>Coba <span class=\"slide-actions\" onclick=\"doButtonAction16()\">Radix Sort<\/span> pada larik masukan contoh diatas untuk penjelasan yang lebih baik.<\/p><br><p>Catat bahwa kita hanya melakukan O(<b>w \u00d7 (N+k)<\/b>) iterasi. Di contoh ini, <b>w = 4<\/b> dan <b>k = 10<\/b>.<\/p>","title":"Radix Sort"},{"id":638,"category":"sorting","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-08-30 16:47:08","updated_at":"2021-12-26 14:42:15","section":183,"code":"$('#title-Radix').click();","section_order":16,"value":"16-1","text":"<p>Sekarang, setelah kita mendiskusikan <i>Radix Sort<\/i>, haruskah kita menggunakannya untuk <b>setiap<\/b> situasi pengurutan?<\/p><br><div>Contohnya, <i>Radix Sort<\/i> harusnya secara teori lebih cepat dalam mengurutkan banyak (<b>N<\/b> sangatlah besar) bilangan-bilangan bulat bertanda 32-bit karena <b style=\"white-space: normal;\">w \u2264 10<\/b><span style=\"white-space: normal;\">&nbsp;digit-digit dan&nbsp;<\/span><b style=\"white-space: normal;\">k = 10<\/b><span style=\"white-space: normal;\">&nbsp;jika kita menginterpretasikan bilangan-bilangan bulat bertanda 32-bit tersebut dalam basis Desimal. O(10 \u00d7 (<\/span><b style=\"white-space: normal;\">N<\/b><span style=\"white-space: normal;\">+10)) = O(<\/span><b style=\"white-space: normal;\">N<\/b><span style=\"white-space: normal;\">).<\/span><\/div>","title":"Algoritma Pengurutan Terbaik?"},{"id":770,"category":"sorting","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2021-12-26 14:38:53","updated_at":"2021-12-26 14:42:51","section":183,"code":"$('#title-Radix').click();","section_order":16,"value":"16-2","text":"<p>Jawabannya: Tergantung.<\/p><br><p>Jika jumlah digit-digit dari semua bilangan-bilangan bulat adalah kecil, mirip, dan ada banyak bilangan-bilangan bulat, maka <i>Radix Sort<\/i> bisa lebih baik daripada algoritma-algoritma O(<b>N<\/b> log <b>N<\/b>) yang berbasis-perbandingan.<\/p><br><p>Tetapi, untuk kasus-kasus seperti mengurutkan <b>A<\/b> = [732834702348928349382734, 1] ke urutan menaik, maka algoritma berbasis-perbandingan apapun akan dengan mudah mengurutkan <b>A<\/b> dimana Radix Sort akan membutuhkan lebih banyak usaha.<\/p><br><p>Kadang-kadang, kita tidak mengurutkan bilangan-bilangan bulat, misalkan mengurutkan bilangan-bilangan pecahan. Pada kasus tersebut, kita perlu menggunakan algoritma-algoritma berbasis-perbandingan yang lebih bersifat umum.<\/p>","title":"Jawabannya"},{"id":570,"category":"sorting","order":17,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:08:53","updated_at":"2020-10-06 04:41:05","section":-1,"code":"","section_order":-1,"value":"17","text":"<p>Ada beberapa properti-properti lain yang bisa digunakan untuk membedakan algoritma-algoritma pengurutan lebih dari sekedar apakah mereka berbasis-pembandingan atau tidak, rekursif atau iteratif.<\/p><br><p>Dalam bagian ini, kita akan membahas tentang di-tempat dibandingkan dengan tidak di-tempat, stabil dibandingkan dengan tidak stabil, dan performa <i>caching<\/i> dari berbagai algoritma-algoritma pengurutan.<\/p>","title":"Properti Tambahan dari Algoritma Pengurutan"},{"id":571,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:09:15","updated_at":"2021-12-26 14:43:14","section":570,"code":"","section_order":17,"value":"17-1","text":"<p>Sebuah algoritma pengurutan dikatakan sebagai <b>pengurutan di-tempat <\/b>jika algoritma tersebut hanya membutuhkan sejumlah ruang konstan (yaitu O(<b>1<\/b>)) selama proses pengurutan. Dengan kata lain, beberapa (konstan) variable-variable ekstra diperbolehkan tetapi kita tidak diperbolehkan untuk menggunakan variable-variable yang mempunyai ukuran tergantung kepada ukuran masukan <b>N<\/b>.<\/p><br><p><a href=\"?slide=10-2\"><u><i>Merge Sort<\/i><\/u><\/a> (versi klasik), karena sub-rutin <samp>merge<\/samp> nya membutuhkan larik temporer tambahan dengan ukuran <b>N<\/b>, tidak di-tempat.<\/p><br><p>Diskusi: Bagaimana dengan <i>Bubble Sort<\/i>, <i>Selection Sort<\/i>, <i>Insertion Sort<\/i>, <i>Quick Sort<\/i> (acak maupun tidak), <i>Counting Sort<\/i>, dan <i>Radix Sort<\/i>. Yang mana saja yang di-tempat?<\/p>","title":"Pengurutan Di-Tempat"},{"id":572,"category":"sorting","order":2,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-02 05:09:24","updated_at":"2017-06-02 05:09:24","section":570,"code":"","section_order":17,"value":"17-2","text":"<p>Sebuah algoritma pengurutan dikatakan <b>stabil <\/b>bila urutan relatif dari elemen-elemen <b>dengan nilai yang sama<\/b> tetap terpelihara oleh algoritma tersebut setelah pengurutan dilakukan.<\/p><br><p>Contoh aplikasi dari pengurutan stabil: Asumsikan bahwa kita memiliki nama-nama murid yang telah diurutkan secara abjad. Sekarang, jika daftar ini diurutkan lagi tetapi berdasarkan nomor grup <i>tutorial<\/i> (ingat bahwa satu grup <i>tutorial<\/i> biasanya mempunyai banyak murid-murid), sebuah algoritma pengurutan yang stabil akan menjamin bahwa semua murid-murid yang berada di dalam grup tutorial yang sama akan tetap tampil dalam urutan abjad.<\/p><br><p>Diskusi: Algoritma-algoritma pengurutan mana saja yang dibahas dalam Kuliah Maya ini yang stabil?<br>Cobalah mengurutkan larik A = {3, 4a, 2, 4b, 1}, lihat bahwa ada dua versi dari 4 (4a duluan, lalu 4b).<\/p>","title":"Pengurutan Stabil"},{"id":573,"category":"sorting","order":3,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-02 05:09:32","updated_at":"2017-06-02 06:17:16","section":570,"code":"","section_order":17,"value":"17-3","text":"<p>Topik ini lebih relevan jika seseorang sudah mengerti konsep bagaimana komputer menangani memori <i>cache<\/i>. Ini adalah salah satu topik di modul Ilmu Komputer lainnya yaitu: \"<i>Computer Organization<\/i>\".<\/p><br><p>Pada dasarnya, sifat dari algoritma partition dari <i>Quick Sort<\/i> sangat baik untuk <i>cache<\/i> sehingga <i>Quick Sort<\/i>, terutama versi acaknya, adalah algoritma pengurutan yang paling sering dipakai di berbagi <i>libraries<\/i> pengurutan, seperti dalam C++ STL sort (digabungkan dengan algoritma lain).<\/p><br><p>Pertanyaan lanjutan: Bagaiman dengan algoritma-algoritma pengurutan yang lain?<\/p>","title":"Performa Cache"},{"id":164,"category":"sorting","order":18,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-20 04:29:58","updated_at":"2020-10-06 04:41:05","section":-1,"code":"","section_order":-1,"value":"18","text":"<p>Kita mendekati akhir dari Kuliah Maya ini.<\/p><br><p>Waktunya untuk beberapa pertanyaan-pertanyaan sederhana.<\/p>","title":"Kuis-Kuis"},{"id":184,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 20:23:35","updated_at":"2017-03-27 04:29:51","section":164,"code":"","section_order":18,"value":"18-1","text":"<br><input class=\"mcq-answer\" id=\"mcq-answer-1\" value=\"5\" hidden><p>Quiz: <b>Which of these algorithms run in O(N log N) on any input array of size N?<\/b><\/p><form><input type=\"radio\" name=\"mcq-1-choice\" value=\"5\"> Merge Sort<br><input type=\"radio\" name=\"mcq-1-choice\" value=\"4\"> Quick Sort (Deterministic)<br><input type=\"radio\" name=\"mcq-1-choice\" value=\"2\"> Bubble Sort<br><input type=\"radio\" name=\"mcq-1-choice\" value=\"3\"> Insertion Sort<br><\/form><button class=\"mcq-submit\" id=\"submit-1\">Submit<\/button> <span id=\"answer-status-1\"><\/span>","title":"Kuis #1"},{"id":185,"category":"sorting","order":2,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-26 20:23:54","updated_at":"2017-03-27 04:30:03","section":164,"code":"","section_order":18,"value":"18-2","text":"<input class=\"msq-answer\" id=\"msq-answer-3\" value=\"13,15,16\" hidden><p>Quiz: <b>Which of these algorithms has worst case time complexity of \u0398(N^2) for sorting N integers?<\/b><\/p><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-3-choice-14\"> Merge Sort<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-3-choice-13\"> Bubble Sort<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-3-choice-16\"> Selection Sort<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-3-choice-23\"> Radix Sort<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-3-choice-15\"> Insertion Sort<br><button class=\"msq-submit\" id=\"submit-3\">Submit<\/button> <span id=\"answer-status-3\"><\/span><br><br><p>\u0398 adalah analisa kompleksitas waktu yang sudah ketat (<i>tight<\/i>) dimana analisa kasus terbaik \u03a9 dan kasus terjelek big-O cocok.<\/p>","title":"Kuis #2"},{"id":562,"category":"sorting","order":19,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:18:30","updated_at":"2020-10-06 04:41:04","section":-1,"code":"","section_order":-1,"value":"19","text":"<p>Kita telah mencapai akhir dari Kuliah Maya pengurutan.<\/p><br><p>Tetapi, masih ada dua algoritma-algoritma pengurutan lainnya di VisuAlgo yang berada didalam struktur-struktur data yang lain: <a href=\".\/heap\"><u>Heap Sort<\/u><\/a> dan <a href=\".\/bst\"><u>Balanced BST Sort<\/u><\/a>. Kita akan membahas mereka saat anda menjalani Kuliah Maya dari dua struktur-struktur data tersebut.<\/p>","title":"Tambahan-Tambahan"},{"id":568,"category":"sorting","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-01 09:00:35","updated_at":"2017-06-02 06:17:34","section":562,"code":"","section_order":19,"value":"19-1","text":"<p>Tantangan rahasianya adalah tentang membandingkan berbagai algoritma-algoritma pengurutan yang dibahas disini menggunakan berbagai tipe-tipe masukan (terurut\/hampir terurut menaik\/menurun; atau masukan acak).<\/p><br><p>Dalam kelas NUS CS2040\/C, hal ini akan dijadikan latihan dirumah dan dibahas pada sesi tutorial.<\/p>","title":"Tantangan"},{"id":677,"category":"sorting","order":2,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2018-02-01 12:53:10","updated_at":"2018-02-01 12:53:25","section":562,"code":"","section_order":19,"value":"19-2","text":"<p>Inversion Index\/Count dari sebuah larik <b>A<\/b> menyatakan seberapa jauh\/dekat <b>A<\/b> dari terurut.<\/p><br><p>Jika larik <b>A<\/b> sudah terurut, maka indeks inversi nya adalah 0.<br>Jika larik <b>A<\/b> sudah terurut terbalik, maka indeks inversi nya adalah maksimum = <b>N*(N-1)\/2<\/b>.<\/p><br><p>Dua elemen <b>A[i]<\/b> dan <b>A[j]<\/b> adalah inversi jika <b>A[i] &gt; A[j]<\/b> dan <b>i &lt; j<\/b>.<\/p><br><p>Kita dapat menghitung indeks inversi dari sebuah larik <b>A<\/b> dalam O(<b>N<\/b><sup>2<\/sup>) dengan melakukan simulasi pertukaran <i>Bubble Sort<\/i>, atau dalam O(<b>N<\/b> log <b>N<\/b>) dengan menghitung inversi dalam proses <samp>merge<\/samp> dari <i>Merge Sort<\/i>.<\/p>","title":"Indeks\/Perhitungan Inversi"},{"id":563,"category":"sorting","order":3,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:18:40","updated_at":"2022-02-02 14:34:17","section":562,"code":"","section_order":19,"value":"19-3","text":"<p>Sebenarnya, kode sumber C++ untuk banyak dari algoritma-algoritma pengurutan ini sudah tersebar di berbagai slide-slide Kuliah Maya. Untuk bahasa pemrograman yang lain, silahkan terjemahkan kode sumber C++ yang diberikan ke bahasa pemrograman lain tersebut.<\/p><br><p>Biasanya, pengurutan hanyalah bagian kecil dari proses pemecahan masalah dan akhir-akhir ini, banyak bahasa-bahasa pemrograman mempunyai fungsi-fungsi pengurutan mereka sendiri-sendiri sehingga kita tidak perlu untuk mengimplementasikan ulang algoritma-algoritma tersebut <i>kecuali sangat perlu<\/i>.<\/p><br><p>Dalam C++, anda bisa menggunakan <a href=\"http:\/\/en.cppreference.com\/w\/cpp\/algorithm\/sort\" target=\"_blank\"><u>std::sort<\/u><\/a> (sangat mungkin adalah algoritma pengurutan hibrid: introsort), <a href=\"http:\/\/en.cppreference.com\/w\/cpp\/algorithm\/stable_sort\" target=\"_blank\"><u>std::stable_sort<\/u><\/a> (sangat mungkin adalah <i>Merge Sort<\/i>), atau <a href=\"http:\/\/en.cppreference.com\/w\/cpp\/algorithm\/partial_sort\" target=\"_blank\"><u>std::partial_sort<\/u><\/a> (sangat mungkin adalah Timbunan Biner) dalam STL algorithm.<br>Dalam Python, anda bisa menggunakan <a href=\"https:\/\/docs.python.org\/3\/library\/stdtypes.html#list.sort\" target=\"_blank\"><u>sort<\/u><\/a> (sangat mungkin adalah algoritma pengurutan hibrid: Timsort).<br>Dalam Java, anda bisa menggunakan <a href=\"https:\/\/docs.oracle.com\/javase\/9\/docs\/api\/java\/util\/Collections.html#sort-java.util.List-\" target=\"_blank\"><u>Collections.sort<\/u><\/a>.<\/p><p><span style=\"white-space: normal;\">Dalam OCaml, anda bisa menggunakan&nbsp;<\/span><a href=\"https:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/List.html\" target=\"_blank\" style=\"white-space: normal;\"><u>List.sort compare list_name<\/u><\/a><span style=\"white-space: normal;\">.<\/span><br><\/p><br><p>Jika fungsi pembandingan adalah spesifik ke sebuah masalah, kita mungkin harus memberikan fungsi pembandingan tambahan kepada rutin pengurutan yang sudah <i>built-in<\/i> tersebut.<\/p>","title":"Implementasi"},{"id":564,"category":"sorting","order":4,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:18:56","updated_at":"2022-01-14 14:11:34","section":562,"code":"","section_order":19,"value":"19-4","text":"<p>Sekarang saatnya bagi anda untuk melihat apakah anda telah mengerti dasar-dasar dari berbagi algoritma-algoritma pengurutan yang dibahas sejauh ini.<\/p><br><p><span class=\"slide-actions\" onclick=\"doButtonAction17()\">Test your understanding here!<\/span><\/p>","title":"Kuis Online"},{"id":565,"category":"sorting","order":5,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-01 07:19:17","updated_at":"2018-02-01 12:53:13","section":562,"code":"","section_order":19,"value":"19-5","text":"<p>Sekarang setelah anda mencapai akhir dari Kuliah Maya ini, apakah anda pikir masalah pengurutan sesimpel pemanggilan rutin pengurutan yang sudah built-in di berbagai bahasa pemrograman?<\/p><br><p>Cobalah masalah-masalah di <i>online judge<\/i> ini untuk menyelidiki lebih lanjut:<br><a href=\"https:\/\/open.kattis.com\/problems\/mjehuric\" target=\"_blank\"><u>Kattis - mjehuric<\/u><\/a><br><a href=\"https:\/\/open.kattis.com\/problems\/sortofsorting\" target=\"_blank\"><u>Kattis - sortofsorting<\/u><\/a>, atau<br><a href=\"https:\/\/open.kattis.com\/problems\/sidewayssorting\" target=\"_blank\"><u>Kattis - sidewayssorting<\/u><\/a><\/p><br><p>Ini bukan akhir dari topik pengurutan. Ketika anda menjelajahi topik-topik lain di VisuAlgo, anda akan menyadari bahwa pengurutan adalah langkah <i>pre-processing<\/i> untuk banyak algoritma-algoritma tingkat lanjut lainnya untuk menyelesaikan masalah-masalah yang lebih sulit, contohnya sebagai langkah <i>pre-processing<\/i> untuk <a href=\".\/mst\"><u>algoritma Kruskal<\/u><\/a>, secara kreatif dipakai didalam struktur data <a href=\".\/suffixarray\"><u>Larik Akhiran (Suffix Array)<\/u><\/a>, dsb.<\/p>","title":"Latihan-Latihan Online Judge"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.bubbleSort, "29,10,14,37,14");
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
        }
        if (slide == '1-2') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
        }
        if (slide == '1-3') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          $("#create").click().addClass("menu-highlighted");
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          $("#create").click().addClass("menu-highlighted");
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
        }
        if (slide == '6-3') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          
        }
        if (slide == '6-4') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          
        }
        if (slide == '6-5') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          
        }
        if (slide == '6-6') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          
        }
        if (slide == '6-7') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          
        }
        if (slide == '6-8') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          
        }
        if (slide == '6-9') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          
        }
        if (slide == '6-10') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          
        }
        if (slide == '6-11') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.bubbleSort, "29,10,14,37,14");
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.bubbleSort, "29,10,14,37,14");
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.bubbleSort, "3,6,11,25,39");
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $('#title-Bubble').click();
$("#sort").addClass("menu-highlighted");
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $('#title-Selection').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.selectionSort, "29,10,14,37,13");
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $('#title-Selection').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.selectionSort, "29,10,14,37,13");
        }
        if (slide == '8-2') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $('#title-Selection').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.selectionSort, "29,10,14,37,13");
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $('#title-Insertion').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.insertionSort, "40,13,20,8");
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $('#title-Insertion').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.insertionSort, "40,13,20,8");
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $('#title-Insertion').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.insertionSort, "40,13,20,8");
        }
        if (slide == '9-3') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $('#title-Insertion').click();
$("#sort").addClass("menu-highlighted");
changeSortType(gw.insertionSort, "40,13,20,8");
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-1') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $('#title-Merge').click();
changeSortType(gw.mergeSort, "1,5,19,20,2,11,15,17");
        }
        if (slide == '11-2') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $('#title-Merge').click();
changeSortType(gw.mergeSort, "1,5,19,20,2,11,15,17");
        }
        if (slide == '11-3') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-4') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-5') {
          $("#e-lecture").html("slide " + slide + " (" + 49 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-6') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $('#title-Merge').click();
changeSortType(gw.mergeSort, "7,2,6,3,8,4,5");
        }
        if (slide == '11-7') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-8') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-9') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $('#title-Merge').click();
        }
        if (slide == '11-10') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          
        }
        if (slide == '11-11') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          
        }
        if (slide == '12') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-1') {
          $("#e-lecture").html("slide " + slide + " (" + 59 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-2') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-3') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-4') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-5') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-6') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-7') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-8') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,27,16");
        }
        if (slide == '12-9') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "27,38,12,39,29,16");
        }
        if (slide == '12-10') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $('#title-Quick').click();
        }
        if (slide == '12-11') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "5,18,23,39,44,50");
        }
        if (slide == '12-12') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "5,18,23,39,44,50");
        }
        if (slide == '12-13') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $('#title-Quick').click();
changeSortType(gw.quickSort, "4,1,3,2,6,5,7");
        }
        if (slide == '13') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $('#title-RandomizedQuick').click();
changeSortType(gw.randomizedQuickSort, DEFAULT_DATA);
        }
        if (slide == '13-1') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          
        }
        if (slide == '13-2') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          
        }
        if (slide == '14') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $('#title-Counting').click();
        }
        if (slide == '14-1') {
          $("#e-lecture").html("slide " + slide + " (" + 79 + "%)");
          $('#title-Counting').click();
        }
        if (slide == '15') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $('#title-Counting').click();
        }
        if (slide == '16') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          $('#title-Radix').click();
        }
        if (slide == '16-1') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          $('#title-Radix').click();
        }
        if (slide == '16-2') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $('#title-Radix').click();
        }
        if (slide == '17') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          
        }
        if (slide == '17-1') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          
        }
        if (slide == '17-2') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          
        }
        if (slide == '17-3') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
        }
        if (slide == '18') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
        }
        if (slide == '18-1') {
          $("#e-lecture").html("slide " + slide + " (" + 91 + "%)");
          
        }
        if (slide == '18-2') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
        }
        if (slide == '19') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
        }
        if (slide == '19-1') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '19-2') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
        }
        if (slide == '19-3') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
        }
        if (slide == '19-4') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
        }
        if (slide == '19-5') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "MEOOXmYvzYv6CeBn1Y6tWoV3KTNyFF458dJojBxk",
            topic: "/sorting".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/sorting".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "MEOOXmYvzYv6CeBn1Y6tWoV3KTNyFF458dJojBxk",
            section: (sectorNum - 1),
            topic: "/sorting".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/sorting".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/id/sorting';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-1-2 .electure-next').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-1-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6-3 .electure-next').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
        $('#electure-6-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-4 .electure-next').click(function() {
          hidePopup();
          runSlide('6-5');
          pushState('6-5');
        });
        $('#electure-6-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-5 .electure-next').click(function() {
          hidePopup();
          runSlide('6-6');
          pushState('6-6');
        });
        $('#electure-6-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
        $('#electure-6-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-7');
          pushState('6-7');
        });
        $('#electure-6-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-5');
          pushState('6-5');
        });
        $('#electure-6-7 .electure-next').click(function() {
          hidePopup();
          runSlide('6-8');
          pushState('6-8');
        });
        $('#electure-6-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-6');
          pushState('6-6');
        });
        $('#electure-6-8 .electure-next').click(function() {
          hidePopup();
          runSlide('6-9');
          pushState('6-9');
        });
        $('#electure-6-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-7');
          pushState('6-7');
        });
        $('#electure-6-9 .electure-next').click(function() {
          hidePopup();
          runSlide('6-10');
          pushState('6-10');
        });
        $('#electure-6-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-8');
          pushState('6-8');
        });
        $('#electure-6-10 .electure-next').click(function() {
          hidePopup();
          runSlide('6-11');
          pushState('6-11');
        });
        $('#electure-6-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-9');
          pushState('6-9');
        });
        $('#electure-6-11 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-10');
          pushState('6-10');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-11');
          pushState('6-11');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-8-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-8-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9-3 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-11-1 .electure-next').click(function() {
          hidePopup();
          runSlide('11-2');
          pushState('11-2');
        });
        $('#electure-11-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-11-2 .electure-next').click(function() {
          hidePopup();
          runSlide('11-3');
          pushState('11-3');
        });
        $('#electure-11-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
        $('#electure-11-3 .electure-next').click(function() {
          hidePopup();
          runSlide('11-4');
          pushState('11-4');
        });
        $('#electure-11-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-2');
          pushState('11-2');
        });
        $('#electure-11-4 .electure-next').click(function() {
          hidePopup();
          runSlide('11-5');
          pushState('11-5');
        });
        $('#electure-11-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-3');
          pushState('11-3');
        });
        $('#electure-11-5 .electure-next').click(function() {
          hidePopup();
          runSlide('11-6');
          pushState('11-6');
        });
        $('#electure-11-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-4');
          pushState('11-4');
        });
        $('#electure-11-6 .electure-next').click(function() {
          hidePopup();
          runSlide('11-7');
          pushState('11-7');
        });
        $('#electure-11-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-5');
          pushState('11-5');
        });
        $('#electure-11-7 .electure-next').click(function() {
          hidePopup();
          runSlide('11-8');
          pushState('11-8');
        });
        $('#electure-11-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-6');
          pushState('11-6');
        });
        $('#electure-11-8 .electure-next').click(function() {
          hidePopup();
          runSlide('11-9');
          pushState('11-9');
        });
        $('#electure-11-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-7');
          pushState('11-7');
        });
        $('#electure-11-9 .electure-next').click(function() {
          hidePopup();
          runSlide('11-10');
          pushState('11-10');
        });
        $('#electure-11-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-8');
          pushState('11-8');
        });
        $('#electure-11-10 .electure-next').click(function() {
          hidePopup();
          runSlide('11-11');
          pushState('11-11');
        });
        $('#electure-11-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-9');
          pushState('11-9');
        });
        $('#electure-11-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-11-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-10');
          pushState('11-10');
        });
        $('#electure-12 .electure-next').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
        $('#electure-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-11');
          pushState('11-11');
        });
        $('#electure-12-1 .electure-next').click(function() {
          hidePopup();
          runSlide('12-2');
          pushState('12-2');
        });
        $('#electure-12-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-12-2 .electure-next').click(function() {
          hidePopup();
          runSlide('12-3');
          pushState('12-3');
        });
        $('#electure-12-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
        $('#electure-12-3 .electure-next').click(function() {
          hidePopup();
          runSlide('12-4');
          pushState('12-4');
        });
        $('#electure-12-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-2');
          pushState('12-2');
        });
        $('#electure-12-4 .electure-next').click(function() {
          hidePopup();
          runSlide('12-5');
          pushState('12-5');
        });
        $('#electure-12-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-3');
          pushState('12-3');
        });
        $('#electure-12-5 .electure-next').click(function() {
          hidePopup();
          runSlide('12-6');
          pushState('12-6');
        });
        $('#electure-12-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-4');
          pushState('12-4');
        });
        $('#electure-12-6 .electure-next').click(function() {
          hidePopup();
          runSlide('12-7');
          pushState('12-7');
        });
        $('#electure-12-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-5');
          pushState('12-5');
        });
        $('#electure-12-7 .electure-next').click(function() {
          hidePopup();
          runSlide('12-8');
          pushState('12-8');
        });
        $('#electure-12-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-6');
          pushState('12-6');
        });
        $('#electure-12-8 .electure-next').click(function() {
          hidePopup();
          runSlide('12-9');
          pushState('12-9');
        });
        $('#electure-12-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-7');
          pushState('12-7');
        });
        $('#electure-12-9 .electure-next').click(function() {
          hidePopup();
          runSlide('12-10');
          pushState('12-10');
        });
        $('#electure-12-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-8');
          pushState('12-8');
        });
        $('#electure-12-10 .electure-next').click(function() {
          hidePopup();
          runSlide('12-11');
          pushState('12-11');
        });
        $('#electure-12-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-9');

          pushState('12-9');
        });
        $('#electure-12-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12-12');
          pushState('12-12');
        });
        $('#electure-12-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-10');
          pushState('12-10');
        });
        $('#electure-12-12 .electure-next').click(function() {
          hidePopup();
          runSlide('12-13');
          pushState('12-13');
        });
        $('#electure-12-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-11');
          pushState('12-11');
        });
        $('#electure-12-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-12-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-12');
          pushState('12-12');
        });
        $('#electure-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-13');
          pushState('12-13');
        });
        $('#electure-13-1 .electure-next').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
        $('#electure-13-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-13-2 .electure-next').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-13-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-14 .electure-next').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
        $('#electure-14-1 .electure-next').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
        $('#electure-14-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-15 .electure-next').click(function() {
          hidePopup();
          runSlide('16');
          pushState('16');
        });
        $('#electure-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-16 .electure-next').click(function() {
          hidePopup();
          runSlide('16-1');
          pushState('16-1');
        });
        $('#electure-16 .electure-prev').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
        $('#electure-16-1 .electure-next').click(function() {
          hidePopup();
          runSlide('16-2');
          pushState('16-2');
        });
        $('#electure-16-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('16');
          pushState('16');
        });
        $('#electure-16-2 .electure-next').click(function() {
          hidePopup();
          runSlide('17');
          pushState('17');
        });
        $('#electure-16-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('16-1');
          pushState('16-1');
        });
        $('#electure-17 .electure-next').click(function() {
          hidePopup();
          runSlide('17-1');
          pushState('17-1');
        });
        $('#electure-17 .electure-prev').click(function() {
          hidePopup();
          runSlide('16-2');

          pushState('16-2');
        });
        $('#electure-17-1 .electure-next').click(function() {
          hidePopup();
          runSlide('17-2');
          pushState('17-2');
        });
        $('#electure-17-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('17');
          pushState('17');
        });
        $('#electure-17-2 .electure-next').click(function() {
          hidePopup();
          runSlide('17-3');
          pushState('17-3');
        });
        $('#electure-17-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('17-1');
          pushState('17-1');
        });
        $('#electure-17-3 .electure-next').click(function() {
          hidePopup();
          runSlide('18');
          pushState('18');
        });
        $('#electure-17-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('17-2');
          pushState('17-2');
        });
        $('#electure-18 .electure-next').click(function() {
          hidePopup();
          runSlide('18-1');
          pushState('18-1');
        });
        $('#electure-18 .electure-prev').click(function() {
          hidePopup();
          runSlide('17-3');
          pushState('17-3');
        });
        $('#electure-18-1 .electure-next').click(function() {
          hidePopup();
          runSlide('18-2');
          pushState('18-2');
        });
        $('#electure-18-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('18');
          pushState('18');
        });
        $('#electure-18-2 .electure-next').click(function() {
          hidePopup();
          runSlide('19');
          pushState('19');
        });
        $('#electure-18-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('18-1');
          pushState('18-1');
        });
        $('#electure-19 .electure-next').click(function() {
          hidePopup();
          runSlide('19-1');
          pushState('19-1');
        });
        $('#electure-19 .electure-prev').click(function() {
          hidePopup();
          runSlide('18-2');
          pushState('18-2');
        });
        $('#electure-19-1 .electure-next').click(function() {
          hidePopup();
          runSlide('19-2');
          pushState('19-2');
        });
        $('#electure-19-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('19');
          pushState('19');
        });
        $('#electure-19-2 .electure-next').click(function() {
          hidePopup();
          runSlide('19-3');
          pushState('19-3');
        });
        $('#electure-19-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('19-1');
          pushState('19-1');
        });
        $('#electure-19-3 .electure-next').click(function() {
          hidePopup();
          runSlide('19-4');
          pushState('19-4');
        });
        $('#electure-19-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('19-2');
          pushState('19-2');
        });
        $('#electure-19-4 .electure-next').click(function() {
          hidePopup();
          runSlide('19-5');
          pushState('19-5');
        });
        $('#electure-19-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('19-3');
          pushState('19-3');
        });
        $('#electure-19-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('19-4');
          pushState('19-4');
        });
      });

      function doButtonAction7() {
        POPUP_IMAGE('https://open.kattis.com/images/site-logo');
      }
      function doButtonAction8() {
        SORT();
      }
      function doButtonAction10() {
        SORT();
      }
      function doButtonAction11() {
        SORT();
      }
      function doButtonAction12() {
        SORT();
      }
      function doButtonAction13() {
        SORT();
      }
      function doButtonAction14() {
        SORT();
      }
      function doButtonAction15() {
        SORT();
      }
      function doButtonAction16() {
        SORT();
      }
      function doButtonAction17() {
        URL('../training?diff=Medium&n=7&tl=0&module=sorting');
      }
      function doButtonAction18() {
        POPUP_IMAGE('https://pbs.twimg.com/profile_images/2618373647/image.jpg');
      }
      function doButtonAction19() {
        URL('../login');
      }
      function doButtonAction20() {
        POPUP_IMAGE('https://puu.sh/vfi6a/e532309371.png');
      }
      function doButtonAction33() {
        changeSortType(gw.bubbleSort, "7,6,5,4,3,2,1");
SORT();
      }
      function doButtonAction95() {
        // add your code here
      }

      $('.electure-print').click(() => {
        window.open(`/id/sorting/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"sort":"65px","create":"92px"};
    var actionsIds = {"create":{"p":"Buat(A)","parents":["create-sorted","create-nearly-sorted","create-many-duplicates"]},"sort":{"p":"Urutkan","onClick":"sort()"}};
    var isOpens = {};
    var len = 2;
    var keys = ["create","sort"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('create');
                    closeAction('sort');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'create').click(function() {
            openAction('create');
                                                                            closeAction('sort');
                                    });
            $('#' + 'sort').click(function() {
            openAction('sort');
                                                closeAction('create');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// Sorting Widget
// original author: Ian Leow Tze Wei
// taken over by Steven on Sat 25 Dec 2021 Christmas day to fix randomize Quick Sort on (many) duplicates

var Sorting = function() {
  var computeInversionIndex = true; // Quick hack on 26 Dec 2021, it will be true from now onwards for Bubble and Merge sort...

  // constants
  var HIGHLIGHT_NONE = "lightblue";
  var HIGHLIGHT_STANDARD = "green";
  var HIGHLIGHT_SPECIAL = "#DC143C";
  var HIGHLIGHT_SORTED = "orange";

  var HIGHLIGHT_LEFT = "#3CB371";
  var HIGHLIGHT_RIGHT = "#9932CC";
  var HIGHLIGHT_PIVOT = "yellow";

  var HIGHLIGHT_GRAY = "#CCCCCC";

  var HIGHLIGHT_RAINBOW = [
    "#FF0000",
    "#FF4000",
    "#FF8000",
    "#FFBF00",
    "#FFFF00",
    "#BFFF00",
    "#80FF00",
    "#40FF00",
    //"#00FF00",
    "#00FF40",
    "#00FF80",
    "#00FFBF",
    "#00FFFF",
    "#00BFFF",
    "#0080FF",
    "#0040FF",
    "#0000FF",
    "#4000FF",
    "#8000FF",
    "#BF00FF",
    "#FF00FF"
  ];

  var HIGHLIGHT_BLUESHADES = [
    HIGHLIGHT_GRAY,
    HIGHLIGHT_NONE,
    "#9DC4E8",
    "#8EB1EB",
    "#7E9DED",
    "#6E89EF",
    "#5E76F1",
    "#4F62F4",
    "#3F4FF6",
    "#2F3BF8",
    "#1F27FA",
    "#1014FD",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF",
    "#0000FF"
  ];

  var POSITION_USE_PRIMARY = "a";
  var POSITION_USE_SECONDARY_IN_DEFAULT_POSITION = "b";

  // Objects definition
  var Entry = function(value, highlight, position, secondaryPositionStatus) {
    this.value = value; // number
    this.highlight = highlight; // string, use HIGHLIGHT_ constants
    this.position = position; // number
    this.secondaryPositionStatus = secondaryPositionStatus; // integer, +ve for position overwrite, -ve for absolute postion (-1 for 0th absolution position)
  }

  var Backlink = function(value, highlight, entryPosition, secondaryPositionStatus) {
    this.value = value; // number
    this.highlight = highlight; // string, use HIGHLIGHT_ constants
    this.entryPosition = entryPosition; // number
    this.secondaryPositionStatus = secondaryPositionStatus; // integer, +ve for position overwrite
  }

  var State = function(entries, backlinks, barsCountOffset, status, lineNo) {
    this.entries = entries; // array of Entry's
    this.backlinks = backlinks; // array of Backlink's
    this.barsCountOffset = barsCountOffset; // how many bars to "disregard" (+ve) or to "imagine" (-ve) w.r.t. state.entries.length when calculating the centre position
    this.status = status;
    this.lineNo = lineNo; //integer or array, line of the code to highlight
  }

  //Helpers
  var EntryBacklinkHelper = new Object();
  EntryBacklinkHelper.appendList = function(entries, backlinks, numArray) {
    for (var i = 0; i < numArray.length; ++i) {
      EntryBacklinkHelper.append(entries, backlinks, numArray[i]);
    }
  }

  EntryBacklinkHelper.append = function(entries, backlinks, newNumber) {
    entries.push(new Entry(newNumber, HIGHLIGHT_NONE, entries.length, POSITION_USE_PRIMARY));
    backlinks.push(new Backlink(newNumber, HIGHLIGHT_NONE, backlinks.length, POSITION_USE_PRIMARY));
  }

  EntryBacklinkHelper.update = function(entries, backlinks) {
    for (var i = 0; i < backlinks.length; ++i) {
      entries[backlinks[i].entryPosition].highlight = backlinks[i].highlight;
      entries[backlinks[i].entryPosition].position = i;
      entries[backlinks[i].entryPosition].secondaryPositionStatus = backlinks[i].secondaryPositionStatus;
    }
  }

  EntryBacklinkHelper.copyEntry = function(oldEntry) {
    return new Entry(oldEntry.value, oldEntry.highlight, oldEntry.position, oldEntry.secondaryPositionStatus);
  }

  EntryBacklinkHelper.copyBacklink = function(oldBacklink) {
    return new Backlink(oldBacklink.value, oldBacklink.highlight, oldBacklink.entryPosition, oldBacklink.secondaryPositionStatus);
  }

  EntryBacklinkHelper.swapBacklinks = function(backlinks, i, j) {
    var swaptemp = backlinks[i];
    backlinks[i] = backlinks[j];
    backlinks[j] = swaptemp;
  }

  var StateHelper = new Object();
  StateHelper.createNewState = function(numArray) {
    var entries = new Array();
    var backlinks = new Array();
    EntryBacklinkHelper.appendList(entries, backlinks, numArray);
    return new State(entries, backlinks, 0, "", 0);
  }

  StateHelper.copyState = function(oldState) {
    var newEntries = new Array();
    var newBacklinks = new Array();
    for (var i = 0; i < oldState.backlinks.length; ++i) {
      newEntries.push(EntryBacklinkHelper.copyEntry(oldState.entries[i]));
      newBacklinks.push(EntryBacklinkHelper.copyBacklink(oldState.backlinks[i]));
    }

    var newLineNo = oldState.lineNo;
    if (newLineNo instanceof Array)
      newLineNo = oldState.lineNo.slice();

    return new State(newEntries, newBacklinks, oldState.barsCountOffset, oldState.status, newLineNo);
  }

  StateHelper.updateCopyPush = function(list, stateToPush) {
    EntryBacklinkHelper.update(stateToPush.entries, stateToPush.backlinks);
    list.push(StateHelper.copyState(stateToPush));
  }

  var FunctionList = new Object();
  FunctionList.text_y = function(d) {
    var barHeight = scaler(d.value);
    if (barHeight < 32) return -15;
    return barHeight-15;
  }

  FunctionList.g_transform = function(d) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight - scaler(d.value)) + ')';
    else if (d.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION)
      return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
    else if (d.secondaryPositionStatus >= 0)
      return 'translate(' + (centreBarsOffset + d.secondaryPositionStatus * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
    else if (d.secondaryPositionStatus < 0)
      return 'translate(' + ((d.secondaryPositionStatus * -1 - 1) * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
    else
      return 'translation(0, 0)'; // error
  }

  FunctionList.radixElement_left = function(d) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return d.position * 65 + centreBarsOffset + "px";
    return d.secondaryPositionStatus * 65 + 17.5 + "px";
  }

  FunctionList.radixElement_bottom = function(d, i) {
    if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
      return 500 - 24 + "px";
    //console.log(i + " " + radixSortBucketOrdering[i]);
    return radixSortBucketOrdering[i] * 30 + 5 + "px";
  }

  FunctionList.radixElement_html = function(d) {
    if (d.highlight == HIGHLIGHT_NONE)
      return d.value;

    var text = "" + d.value;
    while (text.length != 4)
      text = " " + text;

    var positionToHighlight = 0; //positionToHighlight = log_to_base_10(d.highlight), assumes d.highlight is power of 10
    var positionCounter = d.highlight;
    while (positionCounter != 1) {
      positionToHighlight++;
      positionCounter /= 10;
    }

    positionToHighlight = 3-positionToHighlight;

    if (text.charAt(positionToHighlight) != " ") {
      text = text.slice(0, positionToHighlight) +
             "<span style='color: #B40404;'>" +
             text.charAt(positionToHighlight) +
             "</span>" +
             text.slice(positionToHighlight+1);
    }

    text = text.trim();
    return text;
  }

  var makePaler = function(hexColor) {
    var red = Math.floor(parseInt(hexColor.slice(1, 3), 16) + 150);
    var green = Math.floor(parseInt(hexColor.slice(3, 5), 16) + 150);
    var blue = Math.floor(parseInt(hexColor.slice(5, 7), 16) + 150);

    if (red > 255) red = 255;
    if (green > 255) green = 255;
    if (blue > 255) blue = 255;

    red = red.toString(16);
    green = green.toString(16);
    blue = blue.toString(16);

    if (red.length == 1) red = "0" + red;
    if (green.length == 1) green = "0" + green;
    if (blue.length == 1) blue = "0" + blue;
    return "#" + red + green + blue;
  }

  // Variables/Settings
  this.currentNumList = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; // the default

  var barWidth = 50;
  var maxHeight = 230;
  var gapBetweenBars = 5;
  var maxNumOfElements = 18; // dropped from 20 to 15 on 25 Feb, changed to 18 on 18 Mar (otherwise too far left after mobile design integration)
  var gapBetweenPrimaryAndSecondaryRows = 120; // 30; // of the bars

  var maxCountingSortElementValue = 9; // Note that this isn't really customizable, as the code for counting sort is written with this value = 9 in mind.
  var maxRadixSortElementValue = 9999; // Note that this isn't really customizable, as the code for radix sort is written with this value = 9999 in mind.
  var maxElementValue = 50; // for all other sorts - this is fully customizable (seriously)

  var graphElementSize = 10; // The width of the square in the side-graph representing 1 element
  var graphElementGap = 2; // The width of the gap between each element in the side-graph
  var graphRowGap = 10; // The height of the gap between each row in the side graph

  //Code body
  var statelist = new Array();
  var secondaryStatelist = new Array();
  var transitionTime = 500;
  var currentStep = 0;
  var animInterval;
  var issPlaying; //so named so as not to mess with the isPlaying in viz.js

  var quickSortUseRandomizedPivot; //true-false flag
  var mergeSortInversionIndexCounter; //used by merge sort to count the inversion index
  var centreBarsOffset; // x offset to centre the bars in the canvas
  var radixSortBucketOrdering; // used to order the elements inside each bucket (for radix sort). for formatting purposes.

  var isRadixSort = false;
  var isCountingSort = false;

  this.selectedSortFunction;
  // this.useEnhancedBubbleSort = false;
  // this.computeInversionIndex = false; // Quick hack on 26 Dec 2021, it will be true from now onwards for Bubble and Merge sort...

  var canvas = d3.select("#viz")
                 .attr("height", maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows)
                 .attr("width", barWidth * maxNumOfElements);

  var countingSortSecondaryCanvas = d3.select("#viz-counting-sort-secondary-canvas")
                                      .attr("height", 30) // 25 Feb, previously 60
                                      .attr("width", barWidth * maxNumOfElements);

  var radixSortCanvas = d3.select("#viz-radix-sort-canvas");

  var scaler = d3.scale
                 .linear()
                 .range([0, maxHeight]);

  var drawState = function(stateIndex) {
    if (isCountingSort)
      maxHeight = 230/2;
    else
      maxHeight = 230;

    if (isRadixSort)
      drawRadixSortCanvas(statelist[stateIndex], secondaryStatelist[stateIndex]);
    else
      drawBars(statelist[stateIndex]);

    $('#status p').html(statelist[stateIndex].status);
    highlightLine(statelist[stateIndex].lineNo);

    if (isCountingSort)
      drawCountingSortCounters(secondaryStatelist[stateIndex]);
  };

  var drawBars = function(state) {
    scaler.domain([0, d3.max(state.entries, function(d) {
      return d.value;
    })]);

    centreBarsOffset = (maxNumOfElements - (state.entries.length - state.barsCountOffset)) * barWidth / 2;

    var canvasData = canvas.selectAll("g").data(state.entries);

    // Exit ==============================
    var exitData = canvasData.exit()
                             .remove();

    // Entry ==============================
    var newData = canvasData.enter()
                            .append("g")
                            .attr("transform", FunctionList.g_transform);

    newData.append("rect")
           .attr("height", 0)
           .attr("width", 0);

    newData.append("text")
           .attr("dy", ".35em")
           .attr("x", (barWidth - gapBetweenBars) / 2)
           .attr("y", FunctionList.text_y)
           .text(function(d) {
             return d.value;
           });

    // Update ==============================
    canvasData.select("text")
              .transition()
              .attr("y", FunctionList.text_y)
              .text(function(d, i) {
                return d.value;
              });

    canvasData.select("rect")
              .transition()
              .attr("height", function(d) {
                return scaler(d.value);
              })
              .attr("width", barWidth - gapBetweenBars)
              .style("fill", function(d) {
                return d.highlight;
              });

    canvasData.transition()
              .attr("transform", FunctionList.g_transform)
  };

  var drawCountingSortCounters = function(state) {
    var canvasData;
    if (state == null)
      canvasData = countingSortSecondaryCanvas.selectAll("text").data([]);
    else
      canvasData = countingSortSecondaryCanvas.selectAll("text").data(state);

    // Exit ==============================
    var exitData = canvasData
            .exit()
            .remove();

    // Entry ==============================

    var newData = canvasData
            .enter()
            .append("text")
            .attr("dy", ".35em")
            .attr("x", function(d, i) {
              return (i + 5) * barWidth + (barWidth - gapBetweenBars) / 2; // this one controls the frequency text for counting sort
            })
            .attr("y", 10) // 25 Feb, previously 20
            .text(function(d) {
              return d;
            });

    // Update ==============================

    canvasData
            .transition()
            .text(function(d) {
              return d;
            });
  };

  var drawRadixSortCanvas = function(state, secondaryState) {
    centreBarsOffset = (1000 - (state.entries.length * 65 - 10)) / 2; //uh, it's not really bars now, but just reusing the variable - same concept still

    var canvasData = radixSortCanvas.selectAll("div").data(state.entries);
    var radixSortBucketCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    radixSortBucketOrdering = new Array(state.backlinks.length);

    for (var i = 0; i < state.backlinks.length; ++i) {
      if (state.backlinks.secondaryPositionStatus != POSITION_USE_PRIMARY)
        radixSortBucketOrdering[state.backlinks[i].entryPosition] = radixSortBucketCount[state.backlinks[i].secondaryPositionStatus]++;
    }

    // Handle the buckets' DIV's
    if (secondaryState)
      $("#radix-sort-bucket-labels-collection").show();
    else
      $("#radix-sort-bucket-labels-collection").hide();

    // Exit ==============================
    var exitData = canvasData.exit()
                             .remove();

    // Entry ==============================
    var newData = canvasData.enter()
                            .append("div")
                            .classed({"radix-sort-element": true})
                            .style({
                              "left": FunctionList.radixElement_left,
                              "bottom": FunctionList.radixElement_bottom
                            })
                            .html(FunctionList.radixElement_html);

    // Update ==============================
    canvasData.html(FunctionList.radixElement_html)
              .transition()
              .style({
                "left": FunctionList.radixElement_left,
                "bottom": FunctionList.radixElement_bottom
              });
  };

  var generateRandomNumberArray = function(size, limit) {
    var numArray = new Array();
    for (var i = 0; i < size; ++i) {
      numArray.push(generateRandomNumber(1, limit));
    }
    return numArray;
  };

  var generateRandomNumber = function(min, max) { // generates a random integer between min and max (both inclusive)
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  var convertToNumber = function(num) {
    return +num;
  };

  this.createList = function(type) {
    var numArrayMaxListSize = 15; // on 25 Feb 2022, I lower this from 20 down to 15... (to make it nicer on mobile)
    var numArrayMaxElementValue = maxElementValue;
    if (this.selectedSortFunction == this.radixSort) {
      numArrayMaxListSize = 15;
      numArrayMaxElementValue = maxRadixSortElementValue;
    }
    else if (this.selectedSortFunction == this.countingSort) {
      numArrayMaxElementValue = maxCountingSortElementValue;
    }

    var numArray = generateRandomNumberArray(generateRandomNumber(10, numArrayMaxListSize), numArrayMaxElementValue);
    if (type.indexOf("many") != -1) {
      var range = generateRandomNumber(1, 4); // 1, 2, 3, or 4 different numbers only
      numArray = generateRandomNumberArray(generateRandomNumber(10, numArrayMaxListSize), range);
    }

    switch (type) {
      case 'random':
      case 'many-duplicates':
        break; // already done above
      case 'sorted-non-decreasing':
      case 'nearly-sorted-non-decreasing':
        numArray.sort(d3.ascending);
        break;
      case 'sorted-non-increasing':
      case 'nearly-sorted-non-increasing':
        numArray.sort(d3.descending);
        break;
      case 'userdefined':
        numArray = $('#userdefined-input').val().split(",");

        if (numArray.length > numArrayMaxListSize) {
          $("#create-err").html('Anda tidak dapat memiliki lebih dari {maxSize} elemen!'.replace("{maxSize}", numArrayMaxListSize));
          return false;
        }

        for (var i = 0; i < numArray.length; ++i) {
          var temp = convertToNumber(numArray[i]);

          if (numArray[i].trim() == "") {
            $("#create-err").html('Sepertinya ada elemen yang hilang (mungkin ada koma ganda di suatu tempat?)');
            return false;
          }
          if (isNaN(temp)) {
            $("#create-err").html('Sepertinya ada elemen yang tidak valid (bukan angka): {num}.'.replace("{num}", numArray[i]));
            return false;
          }
          if (temp < 1 || temp > numArrayMaxElementValue) {
            $("#create-err").html('Maaf, anda hanya dapat memasukkan nilai di antara 1 dan {maxValue} inklusif. (Angka yang diluar batas: {num}.)'.replace("{maxValue}", numArrayMaxElementValue).replace("{num}", numArray[i]));
            return false;
          }

          numArray[i] = convertToNumber(numArray[i]);
        }
        break;
    }

    if (type.indexOf("nearly") != -1) {
      // To make the list nearly sorted, we take the already sorted list and make swaps
      // such that the list becomes not sorted. The number of such swaps varies from 1 to 2 (customizable).
      // The idea is that the more swaps we make, the less "sorted" the list is.
      //
      // Another limitation is that each swap occurs between elements that are at most 3 positions away.
      while (true) {
        var newNumArray = numArray.slice();

        var numOfSwaps = generateRandomNumber(1, 2);
        for (var i = 0; i < numOfSwaps; ++i) {
          var firstSwappingIndex = generateRandomNumber(0, newNumArray.length - 4);
          var secondSwappingIndex = generateRandomNumber(1, 3) + firstSwappingIndex;

          var temp = numArray[firstSwappingIndex];
          newNumArray[firstSwappingIndex] = numArray[secondSwappingIndex];
          newNumArray[secondSwappingIndex] = temp;
        }

        // We compare the numArray with newNumArray, if they're are the same,
        // we try again, else we reassign numArray to newNumArray and break.
        var isEquals = true;
        for (var i = 0; i < numArray.length; ++i) {
          if (numArray[i] != newNumArray[i]) {
            isEquals = false;
            break;
          }
        }

        if (!isEquals) {
          numArray = newNumArray;
          break;
        }
      }
    }

    this.loadNumberList(numArray);
  }

  this.loadNumberList = function(numArray) {
    $("#create-err").html("");

    issPlaying = false;
    currentStep = 0;
    this.currentNumList = numArray;

    //console.log("numArray: " + numArray);

    statelist = [StateHelper.createNewState(numArray)];
    secondaryStatelist = [null]; // the initial secondary state will be an empty state
    drawState(0);
  }

  this.setSelectedSortFunction = function(f) {
    this.selectedSortFunction = f;
    isRadixSort = (this.selectedSortFunction == this.radixSort);
    isCountingSort = (this.selectedSortFunction == this.countingSort);
  }

  this.sort = function(callback) {
    return this.selectedSortFunction(callback);
  }

  this.radixSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'buat 10 bucket (antrean) untuk tiap digit (0 hingga 9)',
      'untuk tiap penempatan digit',
      'untuk tiap elemen dalam list',
      'pindahkan elemen ke <i>bucket</i>nya masing-masing',
      'untuk tiap bucket, mulai dari digit paling kecil',
      'selama bucket tidak kosong',
      'kembalikan elemen ke dalam list'
    ]);

    secondaryStatelist = [false]; // showBucket flag - if true, shows the DIV's representing the bucketss
    var currentPlacing = 1;
    var targetPlacing = 1;
    var backlinkBuckets = [[], [], [], [], [], [], [], [], [], []];

    var maxValue = d3.max(state.backlinks, function(d) {
      return d.value;
    });
    while (maxValue >= 10) {
      targetPlacing *= 10;
      maxValue = Math.floor(maxValue / 10);
    }

    state.lineNo = 1;

    for (; currentPlacing <= targetPlacing; currentPlacing *= 10) {
      for (var i = 0; i < numElements; ++i)
        state.backlinks[i].highlight = currentPlacing;

      state.lineNo = 2;
      state.status = 'Processing the {currentPlacing}'.replace('{currentPlacing}', currentPlacing == 1 ? 'Ones' : currentPlacing == 10 ? 'Tens' : currentPlacing == 100 ? 'Hundreds' : 'Thousands');
      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(true);

      for (var i = 0; i < numElements; ++i) {
        var currentDigit = Math.floor(state.backlinks[i].value / currentPlacing) % 10;
        state.backlinks[i].secondaryPositionStatus = currentDigit;
        backlinkBuckets[currentDigit].push(state.backlinks[i]);
        state.lineNo = [3,4];
        state.status = 'Moving {val} to bucket no {bucket}'.replace('{val}', state.backlinks[i].value).replace('{bucket}', currentDigit);
        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }

      for (var i = 0, j = 0; i <= 9; ) {
        if (backlinkBuckets[i].length == 0) {
          ++i;
          continue;
        }

        state.backlinks[j++] = backlinkBuckets[i].shift();
      }

      for (var i = 0; i < numElements; ++i) {
        state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
        state.lineNo = [5,6,7];
        state.status = 'Restoring element to position {i} in the list'.replace('{i}', i); // + state.backlinks[i]; //[i].secondaryPositionStatus;
        StateHelper.updateCopyPush(statelist, state);
        secondaryStatelist.push(true);
      }
    }

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE;
    state.lineNo = [];
    state.status = 'We are done';
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(false);

    this.play(callback);
    return true;
  }

  this.countingSort = function(callback) {
    // Note that while we have the maxCountingSortElementValue variable, it isn't really customizable.
    // The code here written is really just for the range 1 to 9.

    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'buat larik kunci (untuk berhitung)',
      'untuk tiap elemen dalam list',
      'naikkan counter-counternya sebesar 1',
      'untuk tiap counter, mulai dari yang paling kecil',
      'while counter bukan 0',
      'kembalikan elemen ke dalam list',
      'turunkan counter sebanyak 1'
    ]);

    var secondaryState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    var backlinkBuckets = [[], [], [], [], [], [], [], [], []];

    state.barsCountOffset = maxCountingSortElementValue;

    for (var i = 1; i <= maxCountingSortElementValue; ++i) {
      EntryBacklinkHelper.append(state.entries, state.backlinks, i);
      state.backlinks[numElements+i-1].highlight = HIGHLIGHT_GRAY;
      state.backlinks[numElements+i-1].secondaryPositionStatus = i * -1 - 5;
    }

    state.lineNo = 1;
    state.status = 'Buat array (untuk berhitung) (dari 1 sampai dengan 9).';

    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist

    for (var i = 0; i < numElements; ++i) {
      var currentValue = state.backlinks[i].value;

      backlinkBuckets[currentValue-1].push(state.backlinks[i]);

      state.backlinks[i].secondaryPositionStatus = currentValue * -1 - 5;

      ++secondaryState[currentValue-1];

      state.backlinks[currentValue + numElements - 1].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue - 1]];

      state.lineNo = [2, 3];
      state.status = 'Naikkan counter dengan kunci {curVal} sebesar 1.'.replace("{curVal}", currentValue);

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist
    }

    for (var i = 0, j = 0; i < maxCountingSortElementValue; ) {
      if (backlinkBuckets[i].length == 0) {
        ++i;
        continue;
      }

      state.backlinks[j++] = backlinkBuckets[i].shift();
    }

    for (var i = 0; i < numElements; ++i) {
      var currentValue = state.backlinks[i].value;

      state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;

      --secondaryState[currentValue-1];

      state.backlinks[currentValue+numElements-1].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue-1]];

      state.lineNo = [4, 5, 6, 7];
      state.status = 'Kembalikan elemen {curVal}, dan turunkan counter dengan kunci tersebut sebesar 1.'.replace("{curVal}", currentValue);

      StateHelper.updateCopyPush(statelist, state);
      secondaryStatelist.push(secondaryState.slice()); //copy the array and push it into the secondary statelist
    }

    state.barsCountOffset = 0;

    for (var i = 1; i <= maxCountingSortElementValue; ++i) {
      state.entries.pop();
      state.backlinks.pop();
    }

    state.lineNo = 0;
    state.status = 'List telah terurut!';
    StateHelper.updateCopyPush(statelist, state);
    secondaryStatelist.push(null); //copy the array and push it into the secondary statelist

    this.play(callback);
    return true;
  }

  this.randomizedQuickSort = function(callback) {
    quickSortUseRandomizedPivot = true;
    quickSortStart();

    this.play(callback);
    return true;
  }

  this.quickSort = function(callback) {
    quickSortUseRandomizedPivot = false;
    quickSortStart();

    this.play(callback);
    return true;
  }

  var quickSortStart = function() {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[statelist.length - 1]);

    populatePseudocode([
      'untuk setiap partisi (yang belum terurut)',
      (quickSortUseRandomizedPivot) ? 'pilih pivot secara acak, tukar dengan elemen pertama' : 'mengeset elemen pertama sebagai pivot',
      '  indeksSimpan = indeksPivot + 1',
      '  <span style="white-space: normal;">for i = indeksPivot+1 to indeksPalingKanan</span>',
      '    <span style="white-space: normal;">if ((a[i] &lt; a[pivot]) atau (sama tapi 50% hoki))</span><br>',
      '      <span style="white-space: normal;">swap(i, indeksSimpan); ++indeksSimpan</span>',
      '  <span style="white-space: normal;">swap(pivot, indeksSimpan-1)</span><br>'
    ]);

    quickSortSplit(state, 0, numElements-1);

    state.lineNo = 0;
    state.status = 'List telah terurut!';

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    StateHelper.updateCopyPush(statelist, state);
  }

  var quickSortSplit = function(state, startIndex, endIndex) { //startIndex & endIndex inclusive
    var cur_partition = state.backlinks.slice(startIndex, endIndex+1).map(function(d) {
                    return d.value;
                  });
    if (cur_partition.toString().length > 20)
      cur_partition = cur_partition.toString().substr(0, 20)+'...';
    state.status = '<span style="white-space: normal;">Bekerja pada partisi [{partition}] (indeks {startIndex} hingga {endIndex}).</span><br>'
                  .replace("{partition}", cur_partition)
                  .replace("{startIndex}", startIndex).replace("{endIndex}", endIndex);
    state.lineNo = 1;

    if (startIndex > endIndex)
      return;

    if (startIndex == endIndex) {
      state.status += ' Karena ukuran partisi == 1, elemen di dalam partisi sudah terurut.';
      state.backlinks[startIndex].highlight = HIGHLIGHT_SORTED;
      StateHelper.updateCopyPush(statelist, state);
      return;
    }

    var middleIndex = quickSortPartition(state, startIndex, endIndex);
    quickSortSplit(state, startIndex, middleIndex-1);
    quickSortSplit(state, middleIndex+1, endIndex);
  }

  var quickSortPartition = function(state, startIndex, endIndex) {
    var pivotIndex;
    if (quickSortUseRandomizedPivot) {
      pivotIndex = generateRandomNumber(startIndex, endIndex);

      state.status += ' Memilih {pivot} (index {index}) secara acak sebagai pivot.'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex);
      state.lineNo = [1, 2];

      state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
      StateHelper.updateCopyPush(statelist, state);

      if (pivotIndex != startIndex) {
        state.status = '<span style="white-space: normal;">Tukar pivot ({pivot}, indeks {index}) dengan elemen pertama ({first}, indeks {firstIndex}). (<b>indeksSimpan</b> = {storeIndex}.)</span>'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex)
              .replace("{first}", state.backlinks[startIndex].value).replace("{firstIndex}", startIndex).replace("{storeIndex}", (startIndex + 1));

        state.lineNo = [2, 3];

        EntryBacklinkHelper.swapBacklinks(state.backlinks, pivotIndex, startIndex);
        pivotIndex = startIndex;
        StateHelper.updateCopyPush(statelist, state);
      }
    }
    else {
      pivotIndex = startIndex;

      state.status += ' Memilih {pivot} sebagai pivot. (<b>indeksSimpan</b> = {storeIndex}).'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{storeIndex}", (startIndex + 1));
      state.lineNo = [1, 2, 3];

      state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
      StateHelper.updateCopyPush(statelist, state);
    }

    var storeIndex = pivotIndex+1;
    var pivotValue = state.backlinks[pivotIndex].value;

    for (var i = storeIndex; i <= endIndex; ++i) {
      state.status = 'Mengecek apakah {val} &lt; {pivot} (pivot) (atau mereka sama tetapi 50% hoki).'.replace("{val}", state.backlinks[i].value).replace("{pivot}", pivotValue);
      state.lineNo = [4, 5];

      state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
      StateHelper.updateCopyPush(statelist, state);
      if ((state.backlinks[i].value < pivotValue) || ((state.backlinks[i].value == pivotValue) && (Math.random() < 0.5))) {
        state.status = '<span style="white-space: normal;">{val} &lt;= {pivot} (pivot) adalah benar. Tukar indeks {idx} (nilai = {val}) dengan elemen di&nbsp;indeksSimpan&nbsp;{storeIdx} (nilai = {storeVal}). (Nilai dari indeksSimpan<b>&nbsp;</b>sekarang<b>&nbsp;</b>= {newStoreIdx}).</span>'
          .replace("{val}", state.backlinks[i].value)
          .replace("{pivot}", pivotValue)
          .replace("{idx}", i).replace("{storeIdx}", storeIndex)
          .replace("{val}", state.backlinks[i].value)
          .replace("{storeVal}", state.backlinks[storeIndex].value)
          .replace("{newStoreIdx}", (storeIndex+1));
        state.lineNo = [4, 6];

        //if (i != storeIndex) { // small behavioral fix on 12 Feb 2022, swap with itself is animated
          EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex, i);
          StateHelper.updateCopyPush(statelist, state);
        //}

        state.backlinks[storeIndex].highlight = HIGHLIGHT_LEFT;
        ++storeIndex;
      }
      else {
        state.backlinks[i].highlight = HIGHLIGHT_RIGHT;
      }
    }
    state.status = 'Iterasi selesai.';
    state.lineNo = 4;
    StateHelper.updateCopyPush(statelist, state);
    if (storeIndex - 1 != pivotIndex) {
      state.status = '<span style="white-space: normal;">Menukar pivot (indeks = {pivotIdx}, nilai = {pivot}) dengan elemen di <b>indeksSimpan</b> - 1 (indeks = {newIdx}, nilai = {newVal}).</span>'.replace("{pivotIdx}", pivotIndex).replace("{pivot}", pivotValue)
            .replace("{newIdx}", (storeIndex - 1)).replace("{newVal}", state.backlinks[storeIndex - 1].value);
      state.lineNo = 7;
      EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex - 1, pivotIndex);
      StateHelper.updateCopyPush(statelist, state);
    }

    state.status = 'Pivot saat ini berada pada posisi terurut-nya.';
    state.lineNo = 7;

    for (var i = startIndex; i <= endIndex; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    state.backlinks[storeIndex - 1].highlight = HIGHLIGHT_SORTED;
    StateHelper.updateCopyPush(statelist, state);

    return storeIndex - 1;
  }

  this.mergeSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'pisahkan tiap elemen menjadi partisi ukuran 1',
      'gabungkan secara rekursif partisi yang bersebelahan',
      '  for i = indeksSisiKiri to indeksSisiKanan',
      '    if nilaiDepanSisiKiri &lt;= nilaiDepanSisiKanan',
      '      copy nilaiDepanSisiKiri',
      '    else: copy nilaiDepanSisiKanan' + (computeInversionIndex ? '; Naikkan InvIdx' : ""),
      'salin elemen-elemen kembali ke larik asalnya'
    ]);

    mergeSortInversionIndexCounter = 0;

    for (var i = 0; i < numElements; ++i) {
      state.backlinks[i].highlight = HIGHLIGHT_RAINBOW[i];
    }

    state.status = 'Kita pisahkan larik sekarang menjadi partisi-partisi berukuran 1 (tiap partisi memiliki warna sendiri).';
    status.lineNo = 1;
    StateHelper.updateCopyPush(statelist, state);

    this.mergeSortSplitMerge(state, 0, numElements);

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; // unhighlight everything

    state.status = 'List telah terurut!';
    if (computeInversionIndex)
      state.status += '<br>(Indeks Inversi = {idx}.)'.replace("{idx}", mergeSortInversionIndexCounter);

    state.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.mergeSortSplitMerge = function(state, startIndex, endIndex) { // startIndex inclusive, endIndex exclusive
    if (endIndex - startIndex <= 1)
      return;

    var middleIndex = Math.ceil((startIndex + endIndex) / 2);
    this.mergeSortSplitMerge(state, startIndex, middleIndex);
    this.mergeSortSplitMerge(state, middleIndex, endIndex);
    this.mergeSortMerge(state, startIndex, middleIndex, endIndex)

    // Copy array back
    state.status = 'Kita sekarang salin elemen-elemen dari larik yang baru ke larik asalnya.';
    state.lineNo = 7;

    var duplicateBacklinks = new Array();
    for (var i = startIndex; i < endIndex; ++i) {
      var newPosition = state.backlinks[i].secondaryPositionStatus;
      duplicateBacklinks[newPosition] = state.backlinks[i];
    }

    for (var i = startIndex; i < endIndex; ++i) {
      state.backlinks[i] = duplicateBacklinks[i];
    }

    for (var i = startIndex; i < endIndex; ++i) {
      state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
      StateHelper.updateCopyPush(statelist, state);
    }
  }

  this.mergeSortMerge = function(state, startIndex, middleIndex, endIndex) {
    var leftIndex = startIndex;
    var rightIndex = middleIndex;

    var newHighlightColor = state.backlinks[startIndex].highlight;

    state.status = 'Gabungkan partisi <span style="white-space: normal;">[{partition1}] (indeks {startIdx1} hingga {endIdx1}) dan [{partition2}] (indeks {startIdx2} hingga {endIdx2}).</span>'
        .replace('{partition1}', state.backlinks.slice(startIndex, middleIndex).map(function(d) {
          return d.value;
        }))
        .replace("{startIdx1}", startIndex).replace("{endIdx1}", (middleIndex - 1))
        .replace("{partition2}", state.backlinks.slice(middleIndex, endIndex).map(function(d) {
          return d.value;
        }))
        .replace("{startIdx2}", middleIndex).replace("{endIdx2}", (endIndex - 1));
    state.lineNo = 2;

    state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);
    state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);
    StateHelper.updateCopyPush(statelist, state);

    for (var i = startIndex; i < endIndex; ++i) {
      // Note here we don't actually copy the elements into a new array, like in a usual mergesort.
      // This is left instead to the mergeSortSplitMerge to handle as it's easier there.
      // (We use the useSecondaryPostion property to overcome this lack-of-copying.)
      if (leftIndex < middleIndex && (rightIndex >= endIndex || state.backlinks[leftIndex].value <= state.backlinks[rightIndex].value)) {
        state.backlinks[leftIndex].highlight = newHighlightColor;
        state.backlinks[leftIndex].secondaryPositionStatus = i;

        if (rightIndex < endIndex) {
          state.status = 'Karena {leftPart} (partisi kiri) &lt;= {rightPart} (partisi kanan), kita ambil {leftPart}.'
            .replace("{leftPart}", state.backlinks[leftIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value)
            .replace("{leftPart}", state.backlinks[leftIndex].value);
        }
        else {
          state.status = 'Karena partisi sebelah kanan adalah kosong, kita ambil {leftPart} (partisi sebelah kiri).'.replace("{leftPart}", state.backlinks[leftIndex].value);
        }
        state.lineNo = [3, 4, 5];

        leftIndex++;
        if (leftIndex != middleIndex)
          state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);

        StateHelper.updateCopyPush(statelist, state);
      }
      else {
        state.backlinks[rightIndex].highlight = newHighlightColor;
        state.backlinks[rightIndex].secondaryPositionStatus = i;

        if (leftIndex < middleIndex) {
          state.status = 'Karena {leftPart} (partisi kiri) &gt; {rightPart} (partisi kanan), kita ambil {rightPart}.'
            .replace("{leftPart}", state.backlinks[leftIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value)
            .replace("{rightPart}", state.backlinks[rightIndex].value);
        }
        else {
          state.status = 'Karena partisi sebelah kiri adalah kosong, kita ambil {rightPart} (partisi sebelah kanan).'.replace("{rightPart}", state.backlinks[rightIndex].value);
        }

        if (computeInversionIndex) {
          mergeSortInversionIndexCounter += middleIndex - leftIndex;
          state.status += '<br>(Kita tambahkan ukuran_partisi_kiri (= {sizeofleft}) ke <b>InvIdx</b> ({inversionidxcounter}).)'
            .replace("{sizeofleft}", (middleIndex - leftIndex)).replace("{inversionidxcounter}", mergeSortInversionIndexCounter);
        }
//        else {
//          state.status += 'aneh'; // what is this?
//        }
        state.lineNo = [3, 6];

        ++rightIndex;
        if (rightIndex != endIndex)
          state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);

        StateHelper.updateCopyPush(statelist, state);
      }
    }
  }

  this.insertionSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'tandai elemen pertama sebagai telah terurut',
      'untuk setiap elemen X yang belum terurut',
      '  &#39;keluarkan&#39; elemennya',
      '  for i = indeksTerurutTerakhir to 0',
      '    if elemen sekarang j &gt; X',
      '      geser elemen yang telah terurut kekanan',
      '    stop loop dan masukkan X disini'
    ]);

    // First element always sorted
    state.lineNo = 1;
    // Mark the first element ({firstVal}) as sorted.
    state.status = 'Tandai elemen pertama ({firstVal}) sebagai telah terurut.'.replace("{firstVal}", state.backlinks[0].value);
    state.backlinks[0].highlight = HIGHLIGHT_SORTED;
    StateHelper.updateCopyPush(statelist, state);

    for (var i = 1; i < numElements; ++i) {
      // Highlight first unsorted element
      state.lineNo = [2, 3];
      // Extract the first unsorted element ({val}).
      state.status = 'Keluarkan elemen belum terurut pertama ({val}).'.replace("{val}", state.backlinks[i].value);
      state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
      state.backlinks[i].secondaryPositionStatus = POSITION_USE_SECONDARY_IN_DEFAULT_POSITION;
      StateHelper.updateCopyPush(statelist, state);

      for (var j = i-1; j >= 0; --j) {
        state.lineNo = 4;
        // Figure where to insert extracted element.
        // Comparing with sorted element {val}.
        state.status = 'Tentukan di mana posisi untuk memasukkan elemen yang telah diambil; membandingkan dengan nilai yang telah terurut {val}.'.replace("{val}", state.backlinks[j].value);;
        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
        StateHelper.updateCopyPush(statelist, state);

        if (state.backlinks[j].value > state.backlinks[j+1].value) {
          state.lineNo = [5, 6];
          // {val1} > {val2} is true.
          // Hence move current sorted element ({val1}) to the right by 1.
          state.status = '{val1} &gt; {val2} adalah benar, maka geser elemen terurut saat ini ({val1}) ke satu posisi di kanan.'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value).replace("{val1}", state.backlinks[j].value);
          EntryBacklinkHelper.swapBacklinks(state.backlinks, j, j+1);
          StateHelper.updateCopyPush(statelist, state);
          state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
        }
        else {
          state.lineNo = 7;
          // {val1} > {val2} is false.
          // Insert extracted element at current position.
          state.status = '{val1} &gt; {val2} adalah salah, masukkan elemen di posisi sekarang.'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value);
          state.backlinks[j].highlight = HIGHLIGHT_SORTED;
          state.backlinks[j+1].secondaryPositionStatus = POSITION_USE_PRIMARY;
          state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
          StateHelper.updateCopyPush(statelist, state);
          break;
        }
      }

      if (state.backlinks[0].secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION) {
        state.lineNo = 4;
        // At beginning of array (nothing to compare).
        // Hence insert extracted element at current position.
        state.status = 'Di bagian depan array (tidak ada yang bisa dibandingkan), maka masukkan elemen di posisi sekarang.';
        state.backlinks[0].secondaryPositionStatus = POSITION_USE_PRIMARY;
        state.backlinks[0].highlight = HIGHLIGHT_SORTED;
        StateHelper.updateCopyPush(statelist, state);
      }
    }

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
    state.lineNo = 0;
    // The array/list is now sorted.
    state.status = 'List telah terurut!';
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.selectionSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);

    populatePseudocode([
      'ulangi (jumlahElemen - 1) kali',
      '  set elemen belum terurut pertama sebagai minimum',
      '  untuk setiap elemen yang belum terurut',
      '    if elemen &lt; nilaiMinimumSekarang',
      '      set elemen sebagai nilai minimum yang baru',
      '  tukar minimum dengan posisi belum terurut pertama'
    ]);

    for (var i = 0; i < numElements-1; ++i) {
      var minPosition = i;

      // Iteration {iteration}: Set {val} as the current minimum.
      // Then iterate through the rest to find the true minimum.
      state.status = 'Iterasi {iteration}: Mengeset {val} sebagai nilai minimum sekarang, lalu cek nilai belum terurut sisanya untuk menemukan nilai minimum sesungguhnya.'.replace("{iteration}", (i+1)).replace("{val}", state.backlinks[i].value);
      state.lineNo = [1, 2, 3];
      state.backlinks[minPosition].highlight = HIGHLIGHT_SPECIAL;

      StateHelper.updateCopyPush(statelist, state);

      for (var j = i+1; j < numElements; ++j) {
        // Check if {val} is smaller than the current minimum ({minVal}).
        state.status = 'Cek apakah {val} lebih kecil daripada nilai minimum sekarang ({minVal}).'.replace("{val}", state.backlinks[j].value).replace("{minVal}", state.backlinks[minPosition].value);
        state.lineNo = 4;
        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
        StateHelper.updateCopyPush(statelist, state);

        state.backlinks[j].highlight = HIGHLIGHT_NONE;

        if (state.backlinks[j].value < state.backlinks[minPosition].value) {
          state.status = 'Mengeset {val} sebagai nilai minimum yang baru.'.replace("{val}", state.backlinks[j].value);
          state.lineNo = 5;
          state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
          state.backlinks[j].highlight = HIGHLIGHT_SPECIAL;

          minPosition = j;
          StateHelper.updateCopyPush(statelist, state);
        }
      }

      if (minPosition != i) { // Highlight the first-most unswapped position, if it isn't the minimum
        // Set {val} as the new minimum.
        state.status = 'Tukar minimum ({minVal}) dengan elemen belum terurut pertama ({element}).'.replace("{minVal}", state.backlinks[minPosition].value).replace("{element}", state.backlinks[i].value);
        state.lineNo = 6;
        state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
        StateHelper.updateCopyPush(statelist, state);

        EntryBacklinkHelper.swapBacklinks(state.backlinks, minPosition, i);
        StateHelper.updateCopyPush(statelist, state);
      }
      else {
        // As the minimum is the first unsorted element, no swap is necessary.
        state.status = 'Karena nilai minimumnya adalah elemen belum terurut yang pertama, tidak ada pertukaran yang diperlukan.';
        state.lineNo = 6;
        StateHelper.updateCopyPush(statelist, state);
      }

      // {val} is now considered sorted.
      state.status = '{val} sekarang dianggap sudah terurut.'.replace("{val}", state.backlinks[i].value);
      state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
      state.backlinks[i].highlight = HIGHLIGHT_SORTED;
      StateHelper.updateCopyPush(statelist, state);
    }

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; // un-highlight everything
    // The array/list is now sorted.
    // (After all iterations, the last element will naturally be sorted.)
    state.status = 'List telah terurut!' + '<br>' + '(Setelah seluruh iterasi dilakukan, elemen terakhir akan terurutkan secara otomatis)';
    status.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.bubbleSort = function(callback) {
    var numElements = statelist[0].backlinks.length;
    var state = StateHelper.copyState(statelist[0]);
    var swapCounter = 0;

    populatePseudocode([
      'do',
      '  <b>ditukar </b>= false',
      '  for i = 1 to indexOfLastUnsortedElement',
      '    if elemenKiri &gt; elemenKanan',
      '      swap(elemenKiri, elemenKanan)',
      '      <b>ditukar </b>= true' + (computeInversionIndex ? '; <b>++jumlahPertukaran</b>' : ""),
      'while <b>ditukar</b>'
    ]);

    var swapped;
    var indexOfLastUnsortedElement = numElements;
    do {
      swapped = false;

      // Set the swapped flag to false.
      // Then iterate from 1 to {endIdx} inclusive.
      state.status = 'Mengeset <b>ditukar </b>menjadi salah. Lalu, melakukan iterasi dari indeks 1 ke {endIdx} inklusif.'.replace("{endIdx}", indexOfLastUnsortedElement-1);
      state.lineNo = [2, 3];
      StateHelper.updateCopyPush(statelist, state);

      for (var i = 1; i < indexOfLastUnsortedElement; ++i) {
        state.backlinks[i-1].highlight = HIGHLIGHT_STANDARD;
        state.backlinks[i].highlight = HIGHLIGHT_STANDARD;

        // Checking if {val1} > {val2} and swap them if that is true.
        // The current value of swapped = {swapped}.
        state.status = 'Mengecek apakah {val1} &gt; {val2} dan tukar keduanya jika iya; <b>ditukar</b> = {swapped}.'.replace("{val1}", state.backlinks[i-1].value).replace("{val2}", state.backlinks[i].value).replace("{swapped}", swapped);
        state.lineNo = 4;
        StateHelper.updateCopyPush(statelist, state);

        if (state.backlinks[i-1].value > state.backlinks[i].value) {
          swapped = true;

          // Swapping the positions of {val1} and {val2}.
          // Set swapped = true.
          state.status = 'Menukar posisi dari {val1} dan {val2} dan set <b>ditukar </b>= benar.'.replace("{val1}", state.backlinks[i-1].value).replace("{val2}", state.backlinks[i].value);
          if (computeInversionIndex) {
            ++swapCounter;
            // For inversion index computation: Add 1 to swapCounter.
            // The current value of swapCounter = {swapCounter}.
            state.status += '<br>(Untuk indeks inversi: Tambahkan 1 ke <b>jumlahPertukaran</b>, sekarang<b> </b>= {swapCounter}.)'.replace("{swapCounter}", swapCounter);
          }

          state.lineNo = [5, 6];

          EntryBacklinkHelper.swapBacklinks(state.backlinks, i, i-1);
          StateHelper.updateCopyPush(statelist, state);
        }

        state.backlinks[i-1].highlight = HIGHLIGHT_NONE;
        state.backlinks[i].highlight = HIGHLIGHT_NONE;
      }

      --indexOfLastUnsortedElement;
      state.backlinks[indexOfLastUnsortedElement].highlight = HIGHLIGHT_SORTED;
      if (swapped == false)
        // No swap is done in this pass.
        // We can terminate Bubble Sort now.
        state.status = 'Tidak ada pertukaran dalam iterasi ini, maka kita bisa menghentikan Bubble Sort sekarang';
      else
        // Mark last unsorted element as sorted now.
        // As at least one swap is done in this pass, we continue.
        state.status = 'Tandai elemen ini sebagai telah terurut. Karena setidaknya satu pertukaran terjadi dalam iterasi ini, kita melakukan iterasi berikutnya.';

      state.lineNo = 7;
      StateHelper.updateCopyPush(statelist, state);
    }
    while (swapped);

    for (var i = 0; i < numElements; ++i)
      state.backlinks[i].highlight = HIGHLIGHT_NONE; //un-highlight everything

    // The array/list is now sorted.
    state.status = 'List telah terurut!';
    if (computeInversionIndex)
      // Inversion Index = {swapCounter}.
      state.status += '<br>(Indeks Inversi = {swapCounter}.)'.replace("{swapCounter}", swapCounter);

    state.lineNo = 0;
    StateHelper.updateCopyPush(statelist, state);

    this.play(callback);
    return true;
  }

  this.clearPseudocode = function() { populatePseudocode([]); }

  var populatePseudocode = function(code) {
    var i = 1;
    for (; i <= 7 && i <= code.length; ++i) {
      $("#code" + i).html(
        code[i - 1].replace(
        /^\s+/,
        function(m) { return m.replace(/\s/g, "&nbsp;"); }
        )
      );
    }
    for (; i <= 7; ++i) {
      $("#code" + i).html("");
    }
  }

  //animation functions
  var drawCurrentState = function() {
    if (currentStep < 0)
      currentStep = 0;
    if (currentStep > statelist.length - 1)
      currentStep = statelist.length - 1;
    $('#progress-bar').slider("value", currentStep);
    drawState(currentStep);
    if (currentStep == (statelist.length-1)) {
      pause(); //in html file
      $('#play img').attr('src', 'https://visualgo.net/img/replay.png').attr('alt', 'replay').attr('title', 'replay');
    }
    else
      $('#play img').attr('src', 'https://visualgo.net/img/play.png').attr('alt', 'play').attr('title', 'play');
  }

  this.getAnimationDuration = function() { return transitionTime; }

  this.setAnimationDuration = function(x) {
    transitionTime = x;
    if (issPlaying) {
      clearInterval(animInterval);
      animInterval = setInterval(function() {
        drawCurrentState();
        if (currentStep < (statelist.length-1))
          ++currentStep;
        else
          clearInterval(animInterval);
      }, transitionTime);
    }
  }

  this.getCurrentIteration = function() { return currentStep; }

  this.getTotalIteration = function() { return statelist.length; }

  this.forceNext = function() {
    if ((currentStep + 1) < statelist.length)
      ++currentStep;
    drawCurrentState();
  }

  this.forcePrevious = function() {
    if ((currentStep-1) >= 0)
      --currentStep;
    drawCurrentState();
  }

  this.jumpToIteration = function(n) {
    currentStep = n;
    drawCurrentState();
  }

  this.play = function(callback) {
    issPlaying = true;
    drawCurrentState();
    animInterval = setInterval(function() {
      drawCurrentState();
      if (currentStep < (statelist.length-1))
        ++currentStep;
      else {
        clearInterval(animInterval);
        if (typeof callback == 'function') callback();
      }
    }, transitionTime);
  }

  this.pause = function() {
    issPlaying = false;
    clearInterval(animInterval);
  }

  this.replay = function() {
    issPlaying = true;
    currentStep = 0;
    drawCurrentState();
    animInterval = setInterval(function() {
      drawCurrentState();
      if (currentStep < (statelist.length-1))
        currentStep++;
      else
        clearInterval(animInterval);
    }, transitionTime);
  }

  this.stop = function() {
    issPlaying = false;
    statelist = [statelist[0]]; //clear statelist to original state, instead of new Array();
    secondaryStatelist = [null];
    currentStep = 0;
    drawState(0);
  }
}

// sorting action
var actionsWidth = 150;
var statusCodetraceWidth = 420;

// local
$(function() {
  AbbreviateTitle();
  var eight_modes = ["Bubble", "Selection", "Insertion", "Merge", "Quick", "RandomizedQuick", "Counting", "Radix"];
  $('#title-'+eight_modes[Math.floor(Math.random()*8)]).click(); // randomly open one of the eight sorting algorithm mode every time
  $('#play').hide();

  d3.selectAll("#radix-sort-bucket-labels-collection span")
    .style({"left": function(d, i) {
                  return 17.5 + i * 65 + "px";
          }});
  var sortMode = getQueryVariable("mode");
  if (sortMode.length > 0) {
     $('#title-' + sortMode).click();
  }
  var createArray = getQueryVariable("create");
  if (createArray.length > 0) {
    $('#userdefined-input').val(createArray);
    createList("userdefined");
  }

});

//this viz-specific code
var gw = new Sorting();

const DEFAULT_DATA       = "3,44,38,5,47,15,36,26,27,2,46,4,19,50,48";
const DEFAULT_COUNT_DATA = "2,3,8,7,1,2,2,2,7,3,9,8,2,1,4"; // drop 5 numbers on 25 Feb , 2, 4, 6, 9, 2";
const DEFAULT_RADIX_DATA = "3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127";

// title changing
function AbbreviateTitle() {
  $('#title-Bubble').text("BUB").attr('title', 'Bubble Sort');
  $('#title-Selection').text("SEL").attr('title', 'Selection Sort');
  $('#title-Insertion').text("INS").attr('title', 'Insertion Sort');
  $('#title-Merge').text("MER").attr('title', 'Merge Sort');
  $('#title-Quick').text("QUI").attr('title', 'Quick Sort');
  $('#title-RandomizedQuick').text("R-Q").attr('title', 'Quick Sort Acak');
  $('#title-Counting').text("COU").attr('title', 'Counting Sort');
  $('#title-Radix').text("RAD").attr('title', 'Radix Sort');
}
$('#title-Bubble').click(function() {
  showStandardCanvas();
  $("#sort-bubble-merge-inversion").css("display", "");
  $('#current-action p').html('Bubble Sort');
  changeSortType(gw.bubbleSort);
  AbbreviateTitle();
  $('#title-Bubble').text('Bubble Sort');
});
$('#title-Selection').click(function() {
  showStandardCanvas();
  hideAllSortingOptions();
  $('#current-action p').html('Selection Sort');
  changeSortType(gw.selectionSort);
  AbbreviateTitle();
  $('#title-Selection').text('Selection Sort');
});
$('#title-Insertion').click(function() {
  showStandardCanvas();
  hideAllSortingOptions();
  $('#current-action p').html('Insertion Sort');
  changeSortType(gw.insertionSort);
  AbbreviateTitle();
  $('#title-Insertion').text('Insertion Sort');
});
$('#title-Merge').click(function() {
  showStandardCanvas();
  hideAllSortingOptions();
  $("#sort-bubble-merge-inversion").css("display", "");
  $('#current-action p').html('Merge Sort');
  AbbreviateTitle();
  changeSortType(gw.mergeSort);
  $('#title-Merge').text('Merge Sort');
});
$('#title-Quick').click(function() {
  showStandardCanvas();
  hideAllSortingOptions();
  $('#current-action p').html('Quick Sort');
  changeSortType(gw.quickSort);
  AbbreviateTitle();
  $('#title-Quick').text('Quick Sort');
});
$('#title-RandomizedQuick').click(function() {
  showStandardCanvas();
  hideAllSortingOptions();
  $('#current-action p').html('Quick Sort Acak');
  changeSortType(gw.randomizedQuickSort);
  AbbreviateTitle();
  $('#title-RandomizedQuick').text('Quick Sort Acak');
});
$('#title-Counting').click(function() {
  showStandardCanvas();
  $("#viz-counting-sort-secondary-canvas").show();
  hideAllSortingOptions();
  $('#current-action p').html('Counting Sort');
  changeSortType(gw.countingSort, DEFAULT_COUNT_DATA);
  AbbreviateTitle();
  $('#title-Counting').text('Counting Sort');
});
$('#title-Radix').click(function() {
  hideAllCanvases();
  $("#viz-radix-sort-canvas").show();
  hideAllSortingOptions();
  $('#current-action p').html('Radix Sort');
  changeSortType(gw.radixSort, DEFAULT_RADIX_DATA);
  AbbreviateTitle();
  $('#title-Radix').text('Radix Sort');
});

function changeSortType(newSortingFunction, customNumberList) {
  if (!customNumberList) {
    // $('#userdefined-input').val(DEFAULT_DATA); // don't use default at all times :O
    createList('random');
  }
  else {
    $('#userdefined-input').val(customNumberList);
    createList('userdefined');
  }

  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  gw.clearPseudocode();
  gw.setSelectedSortFunction(newSortingFunction);
}

function createList(type) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (gw.createList(type)) {
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function sort(callback) {
  gw.computeInversionIndex = $('#sort-bubble-merge-inversion-checkbox').prop('checked');
  if (isPlaying) stop();
  setTimeout(function() {
    if (gw.sort(callback)) {
      $('#current-action').show();
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
}

// sort options
function hideAllSortingOptions() {
  $("#sort-bubble-merge-inversion").css("display", "none");
}

// canvas
function hideAllCanvases() {
  $("#viz").hide();
  $("#viz-counting-sort-secondary-canvas").hide();
  $("#viz-radix-sort-canvas").hide();
}

function showStandardCanvas() {
  $("#viz").show();
  $("#viz-counting-sort-secondary-canvas").hide();
  $("#viz-radix-sort-canvas").hide();
}

var exploreModeData = [];

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  exploreModeData = gw.currentNumList;
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  gw.loadNumberList(exploreModeData);
}

// Lecture action functions
function SORT(mode) {
  hideSlide(function() {
    sort(showSlide);
  });
}
function CUSTOM_ACTION(action, data, mode) {}
</script>
</body>
</html>
